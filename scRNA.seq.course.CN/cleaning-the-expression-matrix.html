<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>7 表达矩阵质控 | scRNA-seq数据分析</title>
  <meta name="description" content="7 表达矩阵质控 | scRNA-seq数据分析" />
  <meta name="generator" content="bookdown 0.11 and GitBook 2.6.7" />

  <meta property="og:title" content="7 表达矩阵质控 | scRNA-seq数据分析" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="7 表达矩阵质控 | scRNA-seq数据分析" />
  
  
  

<meta name="author" content="碱基吃柠檬" />


<meta name="date" content="2019-07-07" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="tabula-muris.html">
<link rel="next" href="references.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- for Facebook -->  
<meta property="og:url" content="https://github.com/sdbiodog" />
<meta property="og:description" content="本项目是将github上经典的scRNA-seq分析教程进行汉化，源项目参见hemberg-lab/scRNA.seq.course" />
<meta property="og:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- for Twitter -->          
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="7 表达矩阵质控 | scRNA-seq数据分析" />
<meta name="twitter:description" content="本项目是将github上经典的scRNA-seq分析教程进行汉化，源项目参见hemberg-lab/scRNA.seq.course" />
<meta name="twitter:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71525309-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="index.html">Table of Contents</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 说在前面的话</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#section-1"><i class="fa fa-check"></i><b>1.1</b> 关于本项目</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#section-2"><i class="fa fa-check"></i><b>1.2</b> 视频</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#github"><i class="fa fa-check"></i><b>1.3</b> GitHub</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#docker-"><i class="fa fa-check"></i><b>1.4</b> Docker 镜像</a><ul>
<li class="chapter" data-level="1.4.1" data-path="index.html"><a href="index.html#section-3"><i class="fa fa-check"></i><b>1.4.1</b> 运行镜像</a></li>
<li class="chapter" data-level="1.4.2" data-path="index.html"><a href="index.html#section-4"><i class="fa fa-check"></i><b>1.4.2</b> 下载数据或其它文件</a></li>
<li class="chapter" data-level="1.4.3" data-path="index.html"><a href="index.html#rstudio"><i class="fa fa-check"></i><b>1.4.3</b> RStudio</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="index.html"><a href="index.html#section-5"><i class="fa fa-check"></i><b>1.5</b> 手动安装</a></li>
<li class="chapter" data-level="1.6" data-path="index.html"><a href="index.html#section-6"><i class="fa fa-check"></i><b>1.6</b> 许可</a></li>
<li class="chapter" data-level="1.7" data-path="index.html"><a href="index.html#section-7"><i class="fa fa-check"></i><b>1.7</b> 准备知识</a></li>
<li class="chapter" data-level="1.8" data-path="index.html"><a href="index.html#section-8"><i class="fa fa-check"></i><b>1.8</b> 联系我们</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html"><i class="fa fa-check"></i><b>2</b> scRNA-seq介绍</a><ul>
<li class="chapter" data-level="2.1" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#bulk-rna-seq"><i class="fa fa-check"></i><b>2.1</b> Bulk RNA-seq</a></li>
<li class="chapter" data-level="2.2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#scrna-seq"><i class="fa fa-check"></i><b>2.2</b> scRNA-seq</a></li>
<li class="chapter" data-level="2.3" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#section-9"><i class="fa fa-check"></i><b>2.3</b> 工作流程</a></li>
<li class="chapter" data-level="2.4" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#section-10"><i class="fa fa-check"></i><b>2.4</b> 计算分析</a></li>
<li class="chapter" data-level="2.5" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#section-11"><i class="fa fa-check"></i><b>2.5</b> 挑战</a></li>
<li class="chapter" data-level="2.6" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#section-12"><i class="fa fa-check"></i><b>2.6</b> 实验方法</a></li>
<li class="chapter" data-level="2.7" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#section-13"><i class="fa fa-check"></i><b>2.7</b> 如何选择合适的平台</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html"><i class="fa fa-check"></i><b>3</b> scRNA-seq原始数据处理</a><ul>
<li class="chapter" data-level="3.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#fastqc"><i class="fa fa-check"></i><b>3.1</b> FastQC</a><ul>
<li class="chapter" data-level="3.1.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-14"><i class="fa fa-check"></i><b>3.1.1</b> 解决方案并下载报告</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-15"><i class="fa fa-check"></i><b>3.2</b> 移除接头和低质量碱基</a><ul>
<li class="chapter" data-level="3.2.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#solution"><i class="fa fa-check"></i><b>3.2.1</b> Solution</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-16"><i class="fa fa-check"></i><b>3.3</b> 文件格式</a><ul>
<li class="chapter" data-level="3.3.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#fastq"><i class="fa fa-check"></i><b>3.3.1</b> FastQ</a></li>
<li class="chapter" data-level="3.3.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#bam"><i class="fa fa-check"></i><b>3.3.2</b> BAM</a></li>
<li class="chapter" data-level="3.3.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#cram"><i class="fa fa-check"></i><b>3.3.3</b> CRAM</a></li>
<li class="chapter" data-level="3.3.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-17"><i class="fa fa-check"></i><b>3.3.4</b> 手动查看文件</a></li>
<li class="chapter" data-level="3.3.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#genome-fasta-gtf"><i class="fa fa-check"></i><b>3.3.5</b> Genome (FASTA, GTF)</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-18"><i class="fa fa-check"></i><b>3.4</b> 测序文库拆分</a><ul>
<li class="chapter" data-level="3.4.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#section-19"><i class="fa fa-check"></i><b>3.4.1</b> 鉴定含有细胞的液滴/微孔</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#starread"><i class="fa fa-check"></i><b>3.5</b> 使用STAR比对read</a><ul>
<li class="chapter" data-level="3.5.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#star"><i class="fa fa-check"></i><b>3.5.1</b> STAR比对命令</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallistopseudo-alignment"><i class="fa fa-check"></i><b>3.6</b> Kallisto和Pseudo-Alignment</a><ul>
<li class="chapter" data-level="3.6.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#k-mer"><i class="fa fa-check"></i><b>3.6.1</b> k-mer是什么?</a></li>
<li class="chapter" data-level="3.6.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#k-merreads"><i class="fa fa-check"></i><b>3.6.2</b> 为什么比对k-mer而不是reads?</a></li>
<li class="chapter" data-level="3.6.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallisto"><i class="fa fa-check"></i><b>3.6.3</b> Kallisto伪比对模式</a></li>
<li class="chapter" data-level="3.6.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallisto-pseudo-alignment"><i class="fa fa-check"></i><b>3.6.4</b> Kallisto Pseudo-Alignment命令</a></li>
<li class="chapter" data-level="3.6.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallisto-1"><i class="fa fa-check"></i><b>3.6.5</b> 理解Kallisto输出结果</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html"><i class="fa fa-check"></i><b>4</b> 构建表达矩阵</a><ul>
<li class="chapter" data-level="4.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-20"><i class="fa fa-check"></i><b>4.1</b> 质量控制</a></li>
<li class="chapter" data-level="4.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-"><i class="fa fa-check"></i><b>4.2</b> Reads 比对</a></li>
<li class="chapter" data-level="4.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-21"><i class="fa fa-check"></i><b>4.3</b> 比对示例</a></li>
<li class="chapter" data-level="4.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mapping-qc"><i class="fa fa-check"></i><b>4.4</b> Mapping QC</a></li>
<li class="chapter" data-level="4.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads"><i class="fa fa-check"></i><b>4.5</b> Reads定量</a></li>
<li class="chapter" data-level="4.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-22"><i class="fa fa-check"></i><b>4.6</b> 唯一分子标识符</a><ul>
<li class="chapter" data-level="4.6.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#umi"><i class="fa fa-check"></i><b>4.6.1</b> UMI介绍</a></li>
<li class="chapter" data-level="4.6.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-23"><i class="fa fa-check"></i><b>4.6.2</b> 比对条形码序列</a></li>
<li class="chapter" data-level="4.6.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#barcodes"><i class="fa fa-check"></i><b>4.6.3</b> Barcodes计数</a></li>
<li class="chapter" data-level="4.6.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-24"><i class="fa fa-check"></i><b>4.6.4</b> 错误校正</a></li>
<li class="chapter" data-level="4.6.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#section-25"><i class="fa fa-check"></i><b>4.6.5</b> 下游分析</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html"><i class="fa fa-check"></i><b>5</b> R/Bioconductor介绍</a><ul>
<li class="chapter" data-level="5.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#r"><i class="fa fa-check"></i><b>5.1</b> 安装R包</a><ul>
<li class="chapter" data-level="5.1.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#cran"><i class="fa fa-check"></i><b>5.1.1</b> CRAN</a></li>
<li class="chapter" data-level="5.1.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#github-1"><i class="fa fa-check"></i><b>5.1.2</b> Github</a></li>
<li class="chapter" data-level="5.1.3" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#bioconductor"><i class="fa fa-check"></i><b>5.1.3</b> Bioconductor</a></li>
<li class="chapter" data-level="5.1.4" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-26"><i class="fa fa-check"></i><b>5.1.4</b> 源码安装</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-27"><i class="fa fa-check"></i><b>5.2</b> 安装说明:</a></li>
<li class="chapter" data-level="5.3" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-28"><i class="fa fa-check"></i><b>5.3</b> 数据类型/类</a><ul>
<li class="chapter" data-level="5.3.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-29"><i class="fa fa-check"></i><b>5.3.1</b> 数值</a></li>
<li class="chapter" data-level="5.3.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-30"><i class="fa fa-check"></i><b>5.3.2</b> 字符/字符串</a></li>
<li class="chapter" data-level="5.3.3" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-31"><i class="fa fa-check"></i><b>5.3.3</b> 逻辑值</a></li>
<li class="chapter" data-level="5.3.4" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-32"><i class="fa fa-check"></i><b>5.3.4</b> 因子</a></li>
<li class="chapter" data-level="5.3.5" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-33"><i class="fa fa-check"></i><b>5.3.5</b> 检查数据类型</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-34"><i class="fa fa-check"></i><b>5.4</b> 基本数据结构</a></li>
<li class="chapter" data-level="5.5" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-35"><i class="fa fa-check"></i><b>5.5</b> 更多信息</a></li>
<li class="chapter" data-level="5.6" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-36"><i class="fa fa-check"></i><b>5.6</b> 数据类型</a><ul>
<li class="chapter" data-level="5.6.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-37"><i class="fa fa-check"></i><b>5.6.1</b> 什么是整洁的数据</a></li>
<li class="chapter" data-level="5.6.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#rich-data"><i class="fa fa-check"></i><b>5.6.2</b> 什么是Rich data?</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#bioconductor-singlecellexperiment--scater"><i class="fa fa-check"></i><b>5.7</b> Bioconductor, <code>SingleCellExperiment</code> 和 <code>scater</code></a><ul>
<li class="chapter" data-level="5.7.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#bioconductor-1"><i class="fa fa-check"></i><b>5.7.1</b> Bioconductor</a></li>
<li class="chapter" data-level="5.7.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#singlecellexperiment-"><i class="fa fa-check"></i><b>5.7.2</b> <code>SingleCellExperiment</code> 类</a></li>
<li class="chapter" data-level="5.7.3" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#scater-"><i class="fa fa-check"></i><b>5.7.3</b> <code>scater</code> 包</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#ggplot2"><i class="fa fa-check"></i><b>5.8</b> ggplot2介绍</a><ul>
<li class="chapter" data-level="5.8.1" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#ggplot2-1"><i class="fa fa-check"></i><b>5.8.1</b> ggplot2是什么?</a></li>
<li class="chapter" data-level="5.8.2" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#ggplot2j"><i class="fa fa-check"></i><b>5.8.2</b> ggplot2j原则</a></li>
<li class="chapter" data-level="5.8.3" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#aes"><i class="fa fa-check"></i><b>5.8.3</b> 使用<code>aes</code>映射函数</a></li>
<li class="chapter" data-level="5.8.4" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#geoms"><i class="fa fa-check"></i><b>5.8.4</b> Geoms</a></li>
<li class="chapter" data-level="5.8.5" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-38"><i class="fa fa-check"></i><b>5.8.5</b> 绘制2个以上细胞的数据</a></li>
<li class="chapter" data-level="5.8.6" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-39"><i class="fa fa-check"></i><b>5.8.6</b> 绘制热图</a></li>
<li class="chapter" data-level="5.8.7" data-path="intro-r-bioc.html"><a href="intro-r-bioc.html#section-40"><i class="fa fa-check"></i><b>5.8.7</b> 主成分分析</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="tabula-muris.html"><a href="tabula-muris.html"><i class="fa fa-check"></i><b>6</b> Tabula Muris</a><ul>
<li class="chapter" data-level="6.1" data-path="tabula-muris.html"><a href="tabula-muris.html#section-41"><i class="fa fa-check"></i><b>6.1</b> 介绍</a></li>
<li class="chapter" data-level="6.2" data-path="tabula-muris.html"><a href="tabula-muris.html#section-42"><i class="fa fa-check"></i><b>6.2</b> 下载数据</a></li>
<li class="chapter" data-level="6.3" data-path="tabula-muris.html"><a href="tabula-muris.html#smartseq2"><i class="fa fa-check"></i><b>6.3</b> 读取Smartseq2数据</a></li>
<li class="chapter" data-level="6.4" data-path="tabula-muris.html"><a href="tabula-muris.html#scater"><i class="fa fa-check"></i><b>6.4</b> 构建scater对象</a></li>
<li class="chapter" data-level="6.5" data-path="tabula-muris.html"><a href="tabula-muris.html#x"><i class="fa fa-check"></i><b>6.5</b> 读取10X数据</a></li>
<li class="chapter" data-level="6.6" data-path="tabula-muris.html"><a href="tabula-muris.html#scater-1"><i class="fa fa-check"></i><b>6.6</b> 创建scater对象</a></li>
<li class="chapter" data-level="6.7" data-path="tabula-muris.html"><a href="tabula-muris.html#section-43"><i class="fa fa-check"></i><b>6.7</b> 进阶练习</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html"><i class="fa fa-check"></i><b>7</b> 表达矩阵质控</a><ul>
<li class="chapter" data-level="7.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exprs-qc"><i class="fa fa-check"></i><b>7.1</b> UMI表达质控</a><ul>
<li class="chapter" data-level="7.1.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-44"><i class="fa fa-check"></i><b>7.1.1</b> 介绍</a></li>
<li class="chapter" data-level="7.1.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#tung"><i class="fa fa-check"></i><b>7.1.2</b> Tung数据集</a></li>
<li class="chapter" data-level="7.1.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-45"><i class="fa fa-check"></i><b>7.1.3</b> 细胞质控</a></li>
<li class="chapter" data-level="7.1.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-48"><i class="fa fa-check"></i><b>7.1.4</b> 细胞过滤</a></li>
<li class="chapter" data-level="7.1.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-51"><i class="fa fa-check"></i><b>7.1.5</b> 手工过滤和自动过滤比较</a></li>
<li class="chapter" data-level="7.1.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-52"><i class="fa fa-check"></i><b>7.1.6</b> 基因分析</a></li>
<li class="chapter" data-level="7.1.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-55"><i class="fa fa-check"></i><b>7.1.7</b> 保存数据</a></li>
<li class="chapter" data-level="7.1.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-56"><i class="fa fa-check"></i><b>7.1.8</b> 大作业</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#reads-1"><i class="fa fa-check"></i><b>7.2</b> Reads表达质控</a></li>
<li class="chapter" data-level="7.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-57"><i class="fa fa-check"></i><b>7.3</b> 数据可视化</a><ul>
<li class="chapter" data-level="7.3.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-58"><i class="fa fa-check"></i><b>7.3.1</b> 介绍</a></li>
<li class="chapter" data-level="7.3.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#visual-pca"><i class="fa fa-check"></i><b>7.3.2</b> PCA plot</a></li>
<li class="chapter" data-level="7.3.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#visual-tsne"><i class="fa fa-check"></i><b>7.3.3</b> tSNE可视化</a></li>
<li class="chapter" data-level="7.3.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#section-62"><i class="fa fa-check"></i><b>7.3.4</b> 大作业</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#reads-2"><i class="fa fa-check"></i><b>7.4</b> Reads数据可视化</a></li>
<li class="chapter" data-level="7.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#identifying-confounding-factors"><i class="fa fa-check"></i><b>7.5</b> Identifying confounding factors</a><ul>
<li class="chapter" data-level="7.5.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction"><i class="fa fa-check"></i><b>7.5.1</b> Introduction</a></li>
<li class="chapter" data-level="7.5.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#correlations-with-pcs"><i class="fa fa-check"></i><b>7.5.2</b> Correlations with PCs</a></li>
<li class="chapter" data-level="7.5.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#explanatory-variables"><i class="fa fa-check"></i><b>7.5.3</b> Explanatory variables</a></li>
<li class="chapter" data-level="7.5.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#other-confounders"><i class="fa fa-check"></i><b>7.5.4</b> Other confounders</a></li>
<li class="chapter" data-level="7.5.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exercise"><i class="fa fa-check"></i><b>7.5.5</b> Exercise</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#identifying-confounding-factors-reads"><i class="fa fa-check"></i><b>7.6</b> Identifying confounding factors (Reads)</a></li>
<li class="chapter" data-level="7.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-theory"><i class="fa fa-check"></i><b>7.7</b> Normalization theory</a><ul>
<li class="chapter" data-level="7.7.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-1"><i class="fa fa-check"></i><b>7.7.1</b> Introduction</a></li>
<li class="chapter" data-level="7.7.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#library-size"><i class="fa fa-check"></i><b>7.7.2</b> Library size</a></li>
<li class="chapter" data-level="7.7.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalisations"><i class="fa fa-check"></i><b>7.7.3</b> Normalisations</a></li>
<li class="chapter" data-level="7.7.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#effectiveness"><i class="fa fa-check"></i><b>7.7.4</b> Effectiveness</a></li>
</ul></li>
<li class="chapter" data-level="7.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-practice-umi"><i class="fa fa-check"></i><b>7.8</b> Normalization practice (UMI)</a><ul>
<li class="chapter" data-level="7.8.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#raw"><i class="fa fa-check"></i><b>7.8.1</b> Raw</a></li>
<li class="chapter" data-level="7.8.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#cpm-1"><i class="fa fa-check"></i><b>7.8.2</b> CPM</a></li>
<li class="chapter" data-level="7.8.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#scran-1"><i class="fa fa-check"></i><b>7.8.3</b> scran</a></li>
<li class="chapter" data-level="7.8.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#downsampling-1"><i class="fa fa-check"></i><b>7.8.4</b> Downsampling</a></li>
<li class="chapter" data-level="7.8.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalisation-for-genetranscript-length"><i class="fa fa-check"></i><b>7.8.5</b> Normalisation for gene/transcript length</a></li>
<li class="chapter" data-level="7.8.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exercise-1"><i class="fa fa-check"></i><b>7.8.6</b> Exercise</a></li>
</ul></li>
<li class="chapter" data-level="7.9" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-practice-reads"><i class="fa fa-check"></i><b>7.9</b> Normalization practice (Reads)</a></li>
<li class="chapter" data-level="7.10" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#dealing-with-confounders"><i class="fa fa-check"></i><b>7.10</b> Dealing with confounders</a><ul>
<li class="chapter" data-level="7.10.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-2"><i class="fa fa-check"></i><b>7.10.1</b> Introduction</a></li>
<li class="chapter" data-level="7.10.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#remove-unwanted-variation"><i class="fa fa-check"></i><b>7.10.2</b> Remove Unwanted Variation</a></li>
<li class="chapter" data-level="7.10.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#combat"><i class="fa fa-check"></i><b>7.10.3</b> Combat</a></li>
<li class="chapter" data-level="7.10.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#mnncorrect"><i class="fa fa-check"></i><b>7.10.4</b> mnnCorrect</a></li>
<li class="chapter" data-level="7.10.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#glm"><i class="fa fa-check"></i><b>7.10.5</b> GLM</a></li>
<li class="chapter" data-level="7.10.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#harmony"><i class="fa fa-check"></i><b>7.10.6</b> Harmony</a></li>
<li class="chapter" data-level="7.10.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#how-to-evaluate-and-compare-confounder-removal-strategies"><i class="fa fa-check"></i><b>7.10.7</b> How to evaluate and compare confounder removal strategies</a></li>
<li class="chapter" data-level="7.10.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#big-exercise"><i class="fa fa-check"></i><b>7.10.8</b> Big Exercise</a></li>
</ul></li>
<li class="chapter" data-level="7.11" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#dealing-with-confounders-reads"><i class="fa fa-check"></i><b>7.11</b> Dealing with confounders (Reads)</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>8</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/lemonbases/scRNA.seq.course.CN" target="blank">碱基吃柠檬</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">scRNA-seq数据分析</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="cleaning-the-expression-matrix" class="section level1">
<h1><span class="header-section-number">7</span> 表达矩阵质控</h1>
<div id="exprs-qc" class="section level2">
<h2><span class="header-section-number">7.1</span> UMI表达质控</h2>
<div id="section-44" class="section level3">
<h3><span class="header-section-number">7.1.1</span> 介绍</h3>
<p>基因表达定量后整理为<strong>表达矩阵</strong>文件，其中每行对应基因(转录本)，每列对应单个细胞。检查矩阵去除read QC或mapping QC中低质量细胞，否则会引入技术噪音，模糊下游感兴趣的生物信号。</p>
<p>目前没有通用的scRNA-seq标准化方法，下文中不同质控期望值因不同实验差异很大。因此，质控时，通过比较数据集内部找到异常细胞，而不是独立的质控标准。当比较不同protocol的数据集的质控指标时，应格外注意。</p>
</div>
<div id="tung" class="section level3">
<h3><span class="header-section-number">7.1.2</span> Tung数据集</h3>
<p>使用芝加哥大学<a href="http://giladlab.uchicago.edu/">Yoav Gilad</a>实验室三个不同个体诱导多能干细胞<a href="http://jdblischak.github.io/singleCellSeq/analysis/">数据集</a> <span class="citation">(Tung et al. <a href="#ref-Tung2017-ba">2017</a>)</span>。细胞分选采用Fluidigm C1平台，同时使用UMI和ERCC <strong>spike-in</strong>，数据文件位于工作目录下的<code>tung</code>文件夹中，这些文件15/03/16创建原始文件的拷贝。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(scater)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)</code></pre>
<p>导入数据和注释:</p>
<pre class="sourceCode r"><code class="sourceCode r">molecules &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;data/tung/molecules.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>)
anno &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;data/tung/annotation.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre>
<p>查看表达矩阵</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(molecules[ , <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</code></pre>
<pre><code>##                 NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03
## ENSG00000237683              0              0              0
## ENSG00000187634              0              0              0
## ENSG00000188976              3              6              1
## ENSG00000187961              0              0              0
## ENSG00000187583              0              0              0
## ENSG00000187642              0              0              0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(anno)</code></pre>
<pre><code>##   individual replicate well      batch      sample_id
## 1    NA19098        r1  A01 NA19098.r1 NA19098.r1.A01
## 2    NA19098        r1  A02 NA19098.r1 NA19098.r1.A02
## 3    NA19098        r1  A03 NA19098.r1 NA19098.r1.A03
## 4    NA19098        r1  A04 NA19098.r1 NA19098.r1.A04
## 5    NA19098        r1  A05 NA19098.r1 NA19098.r1.A05
## 6    NA19098        r1  A06 NA19098.r1 NA19098.r1.A06</code></pre>
<p>数据包括 3 个个体，3次3 重复，共 9 个批次.</p>
<p>使用<code>SingleCellExperiment</code> (SCE)和<code>scater</code>标准化分析。首先创建SCE对象：</p>
<pre class="sourceCode r"><code class="sourceCode r">umi &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">counts =</span> <span class="kw">as.matrix</span>(molecules)), 
    <span class="dt">colData =</span> anno
)</code></pre>
<p>移除在任何细胞都不表达的基因:</p>
<pre class="sourceCode r"><code class="sourceCode r">keep_feature &lt;-<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">counts</span>(umi) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
umi &lt;-<span class="st"> </span>umi[keep_feature, ]</code></pre>
<p>定义control特征(基因) - ERCC spike-ins 和线粒体基因，(作者<a href="http://jdblischak.github.io/singleCellSeq/analysis/qc-filter-ipsc.html">提供</a>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">isSpike</span>(umi, <span class="st">&quot;ERCC&quot;</span>) &lt;-<span class="st"> </span><span class="kw">grepl</span>(<span class="st">&quot;^ERCC-&quot;</span>, <span class="kw">rownames</span>(umi))
<span class="kw">isSpike</span>(umi, <span class="st">&quot;MT&quot;</span>) &lt;-<span class="st"> </span><span class="kw">rownames</span>(umi) <span class="op">%in%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">c</span>(<span class="st">&quot;ENSG00000198899&quot;</span>, <span class="st">&quot;ENSG00000198727&quot;</span>, <span class="st">&quot;ENSG00000198888&quot;</span>,
    <span class="st">&quot;ENSG00000198886&quot;</span>, <span class="st">&quot;ENSG00000212907&quot;</span>, <span class="st">&quot;ENSG00000198786&quot;</span>,
    <span class="st">&quot;ENSG00000198695&quot;</span>, <span class="st">&quot;ENSG00000198712&quot;</span>, <span class="st">&quot;ENSG00000198804&quot;</span>,
    <span class="st">&quot;ENSG00000198763&quot;</span>, <span class="st">&quot;ENSG00000228253&quot;</span>, <span class="st">&quot;ENSG00000198938&quot;</span>,
    <span class="st">&quot;ENSG00000198840&quot;</span>)</code></pre>
<p>计算质量指标:</p>
<pre class="sourceCode r"><code class="sourceCode r">umi &lt;-<span class="st"> </span><span class="kw">calculateQCMetrics</span>(
    umi,
    <span class="dt">feature_controls =</span> <span class="kw">list</span>(
        <span class="dt">ERCC =</span> <span class="kw">isSpike</span>(umi, <span class="st">&quot;ERCC&quot;</span>), 
        <span class="dt">MT =</span> <span class="kw">isSpike</span>(umi, <span class="st">&quot;MT&quot;</span>)
    )
)</code></pre>
</div>
<div id="section-45" class="section level3">
<h3><span class="header-section-number">7.1.3</span> 细胞质控</h3>
<div id="section-46" class="section level4">
<h4><span class="header-section-number">7.1.3.1</span> 文库大小</h4>
<p>查看每个样本检测的总RNA分子数，read counts 或 UMI counts。如果样本中reads/分子数太少，可能细胞破损或捕获失败，应该移除该样本。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(
    umi<span class="op">$</span>total_counts,
    <span class="dt">breaks =</span> <span class="dv">100</span>
)
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="dv">25000</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:total-counts-hist"></span>
<img src="07exprs-overview_files/figure-html/total-counts-hist-1.png" alt="Histogram of library sizes for all cells" width="90%" />
<p class="caption">
Figure 7.1: Histogram of library sizes for all cells
</p>
</div>
<p><strong>练习1</strong></p>
<ol style="list-style-type: decimal">
<li><p>过滤移除多少细胞？</p></li>
<li><p>每个细胞总分子数应该服从什么分布？</p></li>
</ol>
<p><strong>答案</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_total_counts &lt;-<span class="st"> </span>(umi<span class="op">$</span>total_counts <span class="op">&gt;</span><span class="st"> </span><span class="dv">25000</span>)
<span class="kw">table</span>(filter_by_total_counts)</code></pre>
<pre><code>## filter_by_total_counts
## FALSE  TRUE 
##    46   818</code></pre>
</div>
<div id="section-47" class="section level4">
<h4><span class="header-section-number">7.1.3.2</span> 检测基因数</h4>
<p>除了确保每个样品的足够测序深度外，还希望确保读数均衡分布在转录组中。 因此，计算每个样品中检测到的基因数。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(
    umi<span class="op">$</span>total_features_by_counts,
    <span class="dt">breaks =</span> <span class="dv">100</span>
)
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="dv">7000</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:total-features-hist"></span>
<img src="07exprs-overview_files/figure-html/total-features-hist-1.png" alt="Histogram of the number of detected genes in all cells" width="90%" />
<p class="caption">
Figure 7.2: Histogram of the number of detected genes in all cells
</p>
</div>
<p>从上图可以看出大多数细胞检测到7,000-10,000个基因，这对高深度scRAN-seq是正常的。然而，受实验protocol和测序深度的影响。比如基于droplet的方法或样品测序深度低时每个细胞检测基因要少。上图最明显的特征是左侧<strong>拖尾</strong>严重，如果细胞间检测率相同，应该服从正态分布。因此移除分布在左侧尾部的数据(检测少于7000基因的细胞)</p>
<p><strong>联系2</strong></p>
<p>上述过滤了多少细胞？</p>
<p><strong>答案</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_expr_features &lt;-<span class="st"> </span>(umi<span class="op">$</span>total_features_by_counts <span class="op">&gt;</span><span class="st"> </span><span class="dv">7000</span>)
<span class="kw">table</span>(filter_by_expr_features)</code></pre>
<pre><code>## filter_by_expr_features
## FALSE  TRUE 
##   116   748</code></pre>
</div>
<div id="erccsmts" class="section level4">
<h4><span class="header-section-number">7.1.3.3</span> ERCCs和MTs</h4>
<p>细胞质量的另一个衡量标准是ERCC <strong>spike-in</strong> RNA和内源RNA之间的比值。其可用于估计细胞中捕获RNA的总量。 如果<strong>spike-in</strong> RNA较高，表明细胞内源RNA总量低，可能是由于细胞死亡或受到应激导致RNA降解。
Cells with a high level of <em>spike-in</em> RNAs
had low starting amounts of RNA, likely due to the cell being
dead or stressed which may result in the RNA being degraded.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotColData</span>(
    umi,
    <span class="dt">x =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">y =</span> <span class="st">&quot;pct_counts_MT&quot;</span>,
    <span class="dt">colour =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:mt-vs-counts"></span>
<img src="07exprs-overview_files/figure-html/mt-vs-counts-1.png" alt="Percentage of counts in MT genes" width="90%" />
<p class="caption">
Figure 7.3: Percentage of counts in MT genes
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotColData</span>(
    umi,
    <span class="dt">x =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">y =</span> <span class="st">&quot;pct_counts_ERCC&quot;</span>,
    <span class="dt">colour =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:ercc-vs-counts"></span>
<img src="07exprs-overview_files/figure-html/ercc-vs-counts-1.png" alt="Percentage of counts in ERCCs" width="90%" />
<p class="caption">
Figure 7.4: Percentage of counts in ERCCs
</p>
</div>
<p>上述分析表明，来自NA19098.r2批次的大多数细胞具有非常高的ERCC / Endo 比。作者已经解释该批次包含较小尺寸的细胞。</p>
<p><strong>练习3</strong></p>
<p>移除NA19098.r2批次以及移除高表达线粒体基因的细胞(&gt; 10%细胞总计数)</p>
<p><strong>Our answer</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_ERCC &lt;-<span class="st"> </span>umi<span class="op">$</span>batch <span class="op">!=</span><span class="st"> &quot;NA19098.r2&quot;</span>
<span class="kw">table</span>(filter_by_ERCC)</code></pre>
<pre><code>## filter_by_ERCC
## FALSE  TRUE 
##    96   768</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_MT &lt;-<span class="st"> </span>umi<span class="op">$</span>pct_counts_MT <span class="op">&lt;</span><span class="st"> </span><span class="dv">10</span>
<span class="kw">table</span>(filter_by_MT)</code></pre>
<pre><code>## filter_by_MT
## FALSE  TRUE 
##    31   833</code></pre>
<p><strong>练习4</strong></p>
<p>如果研究数据集细胞大小不同(比如正常和衰老细胞)，ERCC和counts比例会是什么分布？</p>
<p><strong>答案</strong></p>
<p>小的细胞(正常细胞)比大的细胞(衰老细胞)具有更高的ERCC/counts比。</p>
</div>
</div>
<div id="section-48" class="section level3">
<h3><span class="header-section-number">7.1.4</span> 细胞过滤</h3>
<div id="section-49" class="section level4">
<h4><span class="header-section-number">7.1.4.1</span> 手动过滤</h4>
<p>根据之前分析定义细胞过滤器：</p>
<pre class="sourceCode r"><code class="sourceCode r">umi<span class="op">$</span>use &lt;-<span class="st"> </span>(
    <span class="co"># sufficient features (genes)</span>
    filter_by_expr_features <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># sufficient molecules counted</span>
<span class="st">    </span>filter_by_total_counts <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># sufficient endogenous RNA</span>
<span class="st">    </span>filter_by_ERCC <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># remove cells with unusual number of reads in MT genes</span>
<span class="st">    </span>filter_by_MT
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(umi<span class="op">$</span>use)</code></pre>
<pre><code>## 
## FALSE  TRUE 
##   207   657</code></pre>
</div>
<div id="section-50" class="section level4">
<h4><span class="header-section-number">7.1.4.2</span> 自动过滤</h4>
<p><code>scater</code>提供根据质控数据进行PCA自动筛选异常细胞的方法。默认情况下，下列统计量用于基于PCA的异常细胞检测：</p>
<ul>
<li><strong>pct_counts_top_100_features</strong></li>
<li><strong>total_features</strong></li>
<li><strong>pct_counts_feature_controls</strong></li>
<li><strong>n_detected_feature_controls</strong></li>
<li><strong>log10_counts_endogenous_features</strong></li>
<li><strong>log10_counts_feature_controls</strong></li>
</ul>
<p><code>scater</code>首先创建一个行为细胞，列为不同QC统计值的矩阵，然后通过<code>mvoutlier</code>包筛选QC统计值与其它细胞显著不同的异常细胞，可能对应低质量细胞。通过PCA画图可视化异常细胞：</p>
<pre class="sourceCode r"><code class="sourceCode r">umi &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
    umi, 
    <span class="dt">use_coldata =</span> <span class="ot">TRUE</span>, 
    <span class="dt">detect_outliers =</span> <span class="ot">TRUE</span>
)
<span class="kw">reducedDimNames</span>(umi)</code></pre>
<pre><code>## [1] &quot;PCA_coldata&quot;</code></pre>
<p>结果存储于umi的<code>$outlier</code>，其标识细胞是否为异常细胞。自动异常细胞检测提供丰富的信息，但是推荐特异性手动检测过滤数据集。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(umi<span class="op">$</span>outlier)</code></pre>
<pre><code>## 
## FALSE  TRUE 
##   791    73</code></pre>
<p>通过PCA查看细胞质量分布</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotReducedDim</span>(
    umi,
    <span class="dt">use_dimred =</span> <span class="st">&quot;PCA_coldata&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>, 
    <span class="dt">shape_by =</span> <span class="st">&quot;use&quot;</span>, 
    <span class="dt">colour_by =</span> <span class="st">&quot;outlier&quot;</span>
)</code></pre>
<p><img src="07exprs-overview_files/figure-html/unnamed-chunk-15-1.png" width="90%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="section-51" class="section level3">
<h3><span class="header-section-number">7.1.5</span> 手工过滤和自动过滤比较</h3>
<p><strong>练习5</strong></p>
<p>用Venn图显示自动和手工筛选的异常细胞</p>
<p><strong>提示</strong>：使用<a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>中<code>vennCounts</code>和<code>vennDiagram</code>函数绘制Venn图。</p>
<p><strong>答案</strong></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(limma)</code></pre>
<pre><code>## 
## 载入程辑包：&#39;limma&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:scater&#39;:
## 
##     plotMDS</code></pre>
<pre><code>## The following object is masked from &#39;package:BiocGenerics&#39;:
## 
##     plotMA</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">auto &lt;-<span class="st"> </span><span class="kw">colnames</span>(umi)[umi<span class="op">$</span>outlier]
man &lt;-<span class="st"> </span><span class="kw">colnames</span>(umi)[<span class="op">!</span>umi<span class="op">$</span>use]
venn.diag &lt;-<span class="st"> </span><span class="kw">vennCounts</span>(
    <span class="kw">cbind</span>(<span class="kw">colnames</span>(umi) <span class="op">%in%</span><span class="st"> </span>auto,
    <span class="kw">colnames</span>(umi) <span class="op">%in%</span><span class="st"> </span>man)
)
<span class="kw">vennDiagram</span>(
    venn.diag,
    <span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;Automatic&quot;</span>, <span class="st">&quot;Manual&quot;</span>),
    <span class="dt">circle.col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;green&quot;</span>)
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:cell-filt-comp"></span>
<img src="07exprs-overview_files/figure-html/cell-filt-comp-1.png" alt="Comparison of the default, automatic and manual cell filters" width="90%" />
<p class="caption">
Figure 7.5: Comparison of the default, automatic and manual cell filters
</p>
</div>
</div>
<div id="section-52" class="section level3">
<h3><span class="header-section-number">7.1.6</span> 基因分析</h3>
<div id="section-53" class="section level4">
<h4><span class="header-section-number">7.1.6.1</span> 基因表达</h4>
<p>除了移除低质量细胞外，通常也移除受技术误差影响较大的基因。而且查看基因表达谱可以帮助改进实验步骤。</p>
<p>查看Top50表达基因占reads的比例</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotHighestExprs</span>(umi, <span class="dt">exprs_values =</span> <span class="st">&quot;counts&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:top50-gene-expr-1"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-qc_files/figure-html/top50-gene-expr-1.png" alt="Number of total counts consumed by the top 50 expressed genes" width="90%" />
<p class="caption">
Figure 7.6: Number of total counts consumed by the top 50 expressed genes
</p>
</div>
<p>Top50表达的基因reads分布相对平缓，表明(但不保证)细胞的转录组覆盖较好。然而在Top15基因中含有spike-ins，表明如果重复实验，稀释spike-in的浓度较好。</p>
</div>
<div id="section-54" class="section level4">
<h4><span class="header-section-number">7.1.6.2</span> 基因过滤</h4>
<p>通常建议移除表达水平低，被认为是<strong>未检测出的</strong>基因。UMI数据中基因<strong>detectable</strong>定义为至少在两个细胞中包含至少1个基因的转录本。read counts数据，基因<strong>detectable</strong>定义为至少在2个细胞检测到至少5个read比对到该基因上。然而，在两种情况下阈值很大程度上取决于测序深度。另外，基因过滤需在细胞过滤之后，因为一些基因可能只在低质量细胞中检测到。（<strong>注意</strong> <code>colData(umi)$use</code>应用于<code>umi</code>数据集）。</p>
<pre class="sourceCode r"><code class="sourceCode r">keep_feature &lt;-<span class="st"> </span><span class="kw">nexprs</span>(
  umi[,<span class="kw">colData</span>(umi)<span class="op">$</span>use], 
  <span class="dt">byrow =</span> <span class="ot">TRUE</span>, 
  <span class="dt">detection_limit =</span> <span class="dv">1</span>
) <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>
<span class="kw">rowData</span>(umi)<span class="op">$</span>use &lt;-<span class="st"> </span>keep_feature</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(keep_feature)</code></pre>
<pre><code>## keep_feature
## FALSE  TRUE 
##  4660 14066</code></pre>
<p>根据细胞类型，实验protocol，测序深度，其它阈值可能也合适。</p>
</div>
</div>
<div id="section-55" class="section level3">
<h3><span class="header-section-number">7.1.7</span> 保存数据</h3>
<p>质控后数据集的维度(注意上述运用的基因过滤)：</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(umi[<span class="kw">rowData</span>(umi)<span class="op">$</span>use, <span class="kw">colData</span>(umi)<span class="op">$</span>use])</code></pre>
<pre><code>## [1] 14066   657</code></pre>
<p>创建log变换的counts值(下面章节用到)，从<code>reducedDim</code>移除保存的PCA结果：</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assay</span>(umi, <span class="st">&quot;logcounts_raw&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">counts</span>(umi) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">reducedDim</span>(umi) &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<p>保存数据:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">saveRDS</span>(umi, <span class="dt">file =</span> <span class="st">&quot;data/tung/umi.rds&quot;</span>)</code></pre>
</div>
<div id="section-56" class="section level3">
<h3><span class="header-section-number">7.1.8</span> 大作业</h3>
<p>使用相同的Blischak数据完成质控分析，使用<code>tung/reads.txt</code>文件读入reads，完成后将结果和我们进行对比(下一章)。</p>
</div>
</div>
<div id="reads-1" class="section level2">
<h2><span class="header-section-number">7.2</span> Reads表达质控</h2>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(scater)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;data/tung/reads.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>)
anno &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;data/tung/annotation.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(reads[ , <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</code></pre>
<pre><code>##                 NA19098.r1.A01 NA19098.r1.A02 NA19098.r1.A03
## ENSG00000237683              0              0              0
## ENSG00000187634              0              0              0
## ENSG00000188976             57            140              1
## ENSG00000187961              0              0              0
## ENSG00000187583              0              0              0
## ENSG00000187642              0              0              0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(anno)</code></pre>
<pre><code>##   individual replicate well      batch      sample_id
## 1    NA19098        r1  A01 NA19098.r1 NA19098.r1.A01
## 2    NA19098        r1  A02 NA19098.r1 NA19098.r1.A02
## 3    NA19098        r1  A03 NA19098.r1 NA19098.r1.A03
## 4    NA19098        r1  A04 NA19098.r1 NA19098.r1.A04
## 5    NA19098        r1  A05 NA19098.r1 NA19098.r1.A05
## 6    NA19098        r1  A06 NA19098.r1 NA19098.r1.A06</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">counts =</span> <span class="kw">as.matrix</span>(reads)), 
    <span class="dt">colData =</span> anno
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">keep_feature &lt;-<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">counts</span>(reads) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
reads &lt;-<span class="st"> </span>reads[keep_feature, ]</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">isSpike</span>(reads, <span class="st">&quot;ERCC&quot;</span>) &lt;-<span class="st"> </span><span class="kw">grepl</span>(<span class="st">&quot;^ERCC-&quot;</span>, <span class="kw">rownames</span>(reads))
<span class="kw">isSpike</span>(reads, <span class="st">&quot;MT&quot;</span>) &lt;-<span class="st"> </span><span class="kw">rownames</span>(reads) <span class="op">%in%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">c</span>(<span class="st">&quot;ENSG00000198899&quot;</span>, <span class="st">&quot;ENSG00000198727&quot;</span>, <span class="st">&quot;ENSG00000198888&quot;</span>,
    <span class="st">&quot;ENSG00000198886&quot;</span>, <span class="st">&quot;ENSG00000212907&quot;</span>, <span class="st">&quot;ENSG00000198786&quot;</span>,
    <span class="st">&quot;ENSG00000198695&quot;</span>, <span class="st">&quot;ENSG00000198712&quot;</span>, <span class="st">&quot;ENSG00000198804&quot;</span>,
    <span class="st">&quot;ENSG00000198763&quot;</span>, <span class="st">&quot;ENSG00000228253&quot;</span>, <span class="st">&quot;ENSG00000198938&quot;</span>,
    <span class="st">&quot;ENSG00000198840&quot;</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads &lt;-<span class="st"> </span><span class="kw">calculateQCMetrics</span>(
    reads,
    <span class="dt">feature_controls =</span> <span class="kw">list</span>(
        <span class="dt">ERCC =</span> <span class="kw">isSpike</span>(reads, <span class="st">&quot;ERCC&quot;</span>), 
        <span class="dt">MT =</span> <span class="kw">isSpike</span>(reads, <span class="st">&quot;MT&quot;</span>)
    )
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(
    reads<span class="op">$</span>total_counts,
    <span class="dt">breaks =</span> <span class="dv">100</span>
)
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="fl">1.3e6</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:total-counts-hist-reads"></span>
<img src="07exprs-overview_files/figure-html/total-counts-hist-reads-1.png" alt="Histogram of library sizes for all cells" width="90%" />
<p class="caption">
Figure 7.7: Histogram of library sizes for all cells
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_total_counts &lt;-<span class="st"> </span>(reads<span class="op">$</span>total_counts <span class="op">&gt;</span><span class="st"> </span><span class="fl">1.3e6</span>)
<span class="kw">table</span>(filter_by_total_counts)</code></pre>
<pre><code>## filter_by_total_counts
## FALSE  TRUE 
##   180   684</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(
    reads<span class="op">$</span>total_features_by_counts,
    <span class="dt">breaks =</span> <span class="dv">100</span>
)
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="dv">7000</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:total-features-hist-reads"></span>
<img src="07exprs-overview_files/figure-html/total-features-hist-reads-1.png" alt="Histogram of the number of detected genes in all cells" width="90%" />
<p class="caption">
Figure 7.8: Histogram of the number of detected genes in all cells
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_expr_features &lt;-<span class="st"> </span>(reads<span class="op">$</span>total_features_by_counts <span class="op">&gt;</span><span class="st"> </span><span class="dv">7000</span>)
<span class="kw">table</span>(filter_by_expr_features)</code></pre>
<pre><code>## filter_by_expr_features
## FALSE  TRUE 
##   116   748</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotColData</span>(
    reads,
    <span class="dt">x =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">y =</span> <span class="st">&quot;pct_counts_MT&quot;</span>,
    <span class="dt">colour =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:mt-vs-counts-reads"></span>
<img src="07exprs-overview_files/figure-html/mt-vs-counts-reads-1.png" alt="Percentage of counts in MT genes" width="90%" />
<p class="caption">
Figure 7.9: Percentage of counts in MT genes
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotColData</span>(
    reads,
    <span class="dt">x =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">y =</span> <span class="st">&quot;pct_counts_ERCC&quot;</span>,
    <span class="dt">colour =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:ercc-vs-counts-reads"></span>
<img src="07exprs-overview_files/figure-html/ercc-vs-counts-reads-1.png" alt="Percentage of counts in ERCCs" width="90%" />
<p class="caption">
Figure 7.10: Percentage of counts in ERCCs
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_ERCC &lt;-<span class="st"> </span>
<span class="st">    </span>reads<span class="op">$</span>batch <span class="op">!=</span><span class="st"> &quot;NA19098.r2&quot;</span> <span class="op">&amp;</span><span class="st"> </span>reads<span class="op">$</span>pct_counts_ERCC <span class="op">&lt;</span><span class="st"> </span><span class="dv">25</span>
<span class="kw">table</span>(filter_by_ERCC)</code></pre>
<pre><code>## filter_by_ERCC
## FALSE  TRUE 
##   103   761</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">filter_by_MT &lt;-<span class="st"> </span>reads<span class="op">$</span>pct_counts_MT <span class="op">&lt;</span><span class="st"> </span><span class="dv">30</span>
<span class="kw">table</span>(filter_by_MT)</code></pre>
<pre><code>## filter_by_MT
## FALSE  TRUE 
##    18   846</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads<span class="op">$</span>use &lt;-<span class="st"> </span>(
    <span class="co"># sufficient features (genes)</span>
    filter_by_expr_features <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># sufficient molecules counted</span>
<span class="st">    </span>filter_by_total_counts <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># sufficient endogenous RNA</span>
<span class="st">    </span>filter_by_ERCC <span class="op">&amp;</span>
<span class="st">    </span><span class="co"># remove cells with unusual number of reads in MT genes</span>
<span class="st">    </span>filter_by_MT
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(reads<span class="op">$</span>use)</code></pre>
<pre><code>## 
## FALSE  TRUE 
##   258   606</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
    reads,
    <span class="dt">use_coldata =</span> <span class="ot">TRUE</span>, 
    <span class="dt">detect_outliers =</span> <span class="ot">TRUE</span>
)
<span class="kw">reducedDimNames</span>(reads)</code></pre>
<pre><code>## [1] &quot;PCA_coldata&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(reads<span class="op">$</span>outlier)</code></pre>
<pre><code>## 
## FALSE  TRUE 
##   753   111</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotReducedDim</span>(
    reads,
    <span class="dt">use_dimred =</span> <span class="st">&quot;PCA_coldata&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>, 
    <span class="dt">shape_by =</span> <span class="st">&quot;use&quot;</span>, 
    <span class="dt">colour_by =</span> <span class="st">&quot;outlier&quot;</span>
)</code></pre>
<p><img src="07exprs-overview_files/figure-html/unnamed-chunk-36-1.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(limma)
auto &lt;-<span class="st"> </span><span class="kw">colnames</span>(reads)[reads<span class="op">$</span>outlier]
man &lt;-<span class="st"> </span><span class="kw">colnames</span>(reads)[<span class="op">!</span>reads<span class="op">$</span>use]
venn.diag &lt;-<span class="st"> </span><span class="kw">vennCounts</span>(
    <span class="kw">cbind</span>(<span class="kw">colnames</span>(reads) <span class="op">%in%</span><span class="st"> </span>auto,
    <span class="kw">colnames</span>(reads) <span class="op">%in%</span><span class="st"> </span>man)
)
<span class="kw">vennDiagram</span>(
    venn.diag,
    <span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;Automatic&quot;</span>, <span class="st">&quot;Manual&quot;</span>),
    <span class="dt">circle.col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;green&quot;</span>)
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:cell-filt-comp-reads"></span>
<img src="07exprs-overview_files/figure-html/cell-filt-comp-reads-1.png" alt="Comparison of the default, automatic and manual cell filters" width="90%" />
<p class="caption">
Figure 7.11: Comparison of the default, automatic and manual cell filters
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotHighestExprs</span>(reads, <span class="dt">exprs_values =</span> <span class="st">&quot;counts&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:top50-gene-expr-reads"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-qc-reads_files/figure-html/top50-gene-expr-reads-1.png" alt="Number of total counts consumed by the top 50 expressed genes" width="90%" />
<p class="caption">
Figure 7.12: Number of total counts consumed by the top 50 expressed genes
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">keep_feature &lt;-<span class="st"> </span><span class="kw">nexprs</span>(
  reads[,<span class="kw">colData</span>(reads)<span class="op">$</span>use], 
  <span class="dt">byrow =</span> <span class="ot">TRUE</span>, 
  <span class="dt">detection_limit =</span> <span class="dv">1</span>
) <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>
<span class="kw">rowData</span>(reads)<span class="op">$</span>use &lt;-<span class="st"> </span>keep_feature</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(keep_feature)</code></pre>
<pre><code>## keep_feature
## FALSE  TRUE 
##  2664 16062</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(reads[<span class="kw">rowData</span>(reads)<span class="op">$</span>use, <span class="kw">colData</span>(reads)<span class="op">$</span>use])</code></pre>
<pre><code>## [1] 16062   606</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assay</span>(reads, <span class="st">&quot;logcounts_raw&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">counts</span>(reads) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">reducedDim</span>(reads) &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">saveRDS</span>(reads, <span class="dt">file =</span> <span class="st">&quot;data/tung/reads.rds&quot;</span>)</code></pre>
<p>通过比对图<a href="cleaning-the-expression-matrix.html#fig:cell-filt-comp">7.5</a> 和 图<a href="cleaning-the-expression-matrix.html#fig:cell-filt-comp-reads">7.11</a>发现，基于reads过滤比对基于UMI的分析去除了更多的细胞。如果返回比较结果，应该得出结论ERCC和MT过滤对基于reads的分析更严格。</p>
</div>
<div id="section-57" class="section level2">
<h2><span class="header-section-number">7.3</span> 数据可视化</h2>
<div id="section-58" class="section level3">
<h3><span class="header-section-number">7.3.1</span> 介绍</h3>
<p>本章继续使用之前章节产生的过滤后<code>Tung</code>数据集，我们将使用几种数据可视化方式，以便评估质量控制后表达矩阵的改变。<code>scater</code>包提供了几种有用的函数来简化可视化。</p>
<p>scRNA-sq分析的一个重要方面是控制批次效应。批次效应是实验过程中引入的技术偏差。比如，不同实验室准备的样品或同一实验室不同时间准备的样品，同一批处理的数据相似度更高。最差的情况，批次效应可能被<a href="http://f1000research.com/articles/4-121/v1">误认为</a> 真实的生物差异。<code>Tung</code>数据详细记录样品处理过程，允许探索批次效应问题。理想情况下，同一个体细胞聚集在一起，不同group对应每个个体，这说明存在批次效应。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(scater)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
umi &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/umi.rds&quot;</span>)
umi.qc &lt;-<span class="st"> </span>umi[<span class="kw">rowData</span>(umi)<span class="op">$</span>use, <span class="kw">colData</span>(umi)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(umi.qc)<span class="op">$</span>is_feature_control</code></pre>
</div>
<div id="visual-pca" class="section level3">
<h3><span class="header-section-number">7.3.2</span> PCA plot</h3>
<p>查看数据分布的最简单方式是主成分分析，然后查看前两个主成分。</p>
<p><a href="https://en.wikipedia.org/wiki/Principal_component_analysis">主成分分析(PCA)</a> 是一种统计方法，使用正交变换将观察变量转化为一组线性无关的变量，称之为主成分。主成分的个数少于或等于原始变量数。</p>
<p>数学上，主成分对应协方差矩阵的特征向量，特征向量按照特征值进行排序，使得第一主成分解释最大的数据变异，后续主成分在与前面主成分正交的约下具有最高的方差。(图片来自<a href="http://www.nlpca.org/pca_principal_component_analysis.html">这里</a>)。</p>
<div class="figure" style="text-align: center"><span id="fig:clust-pca"></span>
<img src="figures/pca.png" alt="Schematic representation of PCA dimensionality reduction" width="100%" />
<p class="caption">
Figure 7.13: Schematic representation of PCA dimensionality reduction
</p>
</div>
<div id="before-qc" class="section level4">
<h4><span class="header-section-number">7.3.2.1</span> Before QC</h4>
<p>对数变换前:</p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;counts&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-before-qc1"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-pca-before-qc1-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.14: PCA plot of the tung data
</p>
</div>
<p>对数变换后:</p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-before-qc2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-pca-before-qc2-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.15: PCA plot of the tung data
</p>
</div>
<p>显然，对数变换更适合我们的数据，其减少了第一组成分的变异，分离出一些生物效应。而且使表达数据的分布更符合正态分布，后续分析和章节中我们默认使用log变换的counts数据。</p>
<p><strong>然而，仅仅对数变换不足以解释细胞间不同计算因子(如测序深度)带来的差异。因此，下游分析中不要使用<code>logcounts_raw</code>，而是使用<code>SingleCellExperiment</code>对象的<code>logcounts</code>,其不仅仅对数变换，而且根据文库大小进行标准化(比如CPM标准化)。本课程中我们仅使用<code>logcounts_raw</code>进行演示！</strong></p>
</div>
<div id="section-59" class="section level4">
<h4><span class="header-section-number">7.3.2.2</span> 质控后</h4>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi.qc[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-after-qc"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-pca-after-qc-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.16: PCA plot of the tung data
</p>
</div>
<p>比较图 <a href="cleaning-the-expression-matrix.html#fig:expr-overview-pca-before-qc2">7.15</a> 和图 <a href="cleaning-the-expression-matrix.html#fig:expr-overview-pca-after-qc">7.16</a>, 发现质控后NA19098.r2不再是离群组。</p>
<p>默认情况下，scater使用500个变化最大的基因进行PCA分析，可以通过<code>ntop</code>参数进行修改。</p>
<p><strong>练习1</strong>
如果使用所有的14066基因，PCA图会如何？只是用50个基因呢？为什么第一主成分解释整体变异差别那么大？</p>
<p><strong>提示</strong> 使用<code>plotPCA</code>函数中<code>ntop</code>参数</p>
<p><strong>答案</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">ntop =</span> <span class="dv">14066</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-after-qc-exercise1-1"></span>
<img src="https://lemonbases.github.io/scRNA.seq.course.CN/07exprs-overview_files/figure-html/expr-overview-pca-after-qc-exercise1-1-1.png" alt="PCA plot of the tung data (14214 genes)" width="90%" />
<p class="caption">
Figure 7.17: PCA plot of the tung data (14214 genes)
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">ntop =</span> <span class="dv">50</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-after-qc-exercise1-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-pca-after-qc-exercise1-2-1.png" alt="PCA plot of the tung data (50 genes)" width="90%" />
<p class="caption">
Figure 7.18: PCA plot of the tung data (50 genes)
</p>
</div>
</div>
</div>
<div id="visual-tsne" class="section level3">
<h3><span class="header-section-number">7.3.3</span> tSNE可视化</h3>
<p>scRNA-seq数据可视化另一个常用方法是tSNE。tSNE](<a href="https://lvdmaaten.github.io/tsne/" class="uri">https://lvdmaaten.github.io/tsne/</a>) (t-Distributed Stochastic Neighbor Embedding)整合降维(比如PCA)和最近邻网络随机游走在保持细胞间局部距离的基础上，将高维数据(比如，我们的14214维表达矩阵)映射到二维空间。和PCA不同的是，tSNE算法具有随机性，即在同一数据集上运行结果可能不同。由于非线性和随机性，tSNE结果难以直观解释。为了确保可重复性，固定随机数“seed”，以便始终得到相同结果。</p>
<div id="section-60" class="section level4">
<h4><span class="header-section-number">7.3.3.1</span> 质控前</h4>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    umi[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">130</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-before-qc"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-tsne-before-qc-1.png" alt="tSNE map of the tung data" width="90%" />
<p class="caption">
Figure 7.19: tSNE map of the tung data
</p>
</div>
</div>
<div id="section-61" class="section level4">
<h4><span class="header-section-number">7.3.3.2</span> 质控后</h4>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">130</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-tsne-after-qc-1.png" alt="tSNE map of the tung data" width="90%" />
<p class="caption">
Figure 7.20: tSNE map of the tung data
</p>
</div>
<p>因为随机性和非线性，解释PCA和tSNE结果通常较难，不太直观，然而，在这种情况他们提供了相似的数据概览。比较图<a href="cleaning-the-expression-matrix.html#fig:expr-overview-tsne-before-qc">7.19</a>和图<a href="cleaning-the-expression-matrix.html#fig:expr-overview-tsne-after-qc">7.20</a>发现，质控过滤后的NA19098.r2样本不再是异常值。</p>
<p>tSNE中<code>perplexity</code>参数表示构建最近邻网络的邻居数，<code>perplexity</code>越高，网络越密集，细胞聚集在一起。<code>perplexity</code>越低，网络越稀疏，细胞群体彼此分离。<code>scater</code>使用默认perplexity为细胞总数除以5(向下取整)。</p>
<p>tSNE的缺点见<a href="http://distill.pub/2016/misread-tsne/">这里</a>。</p>
<p><strong>练习2</strong>
当perplexity设置为10或200时对tSNE结果的影响？</p>
<p><strong>答案</strong></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">10</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc-exercise2-1"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-tsne-after-qc-exercise2-1-1.png" alt="tSNE map of the tung data (perplexity = 10)" width="90%" />
<p class="caption">
Figure 7.21: tSNE map of the tung data (perplexity = 10)
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">200</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc-exercise2-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview_files/figure-html/expr-overview-tsne-after-qc-exercise2-2-1.png" alt="tSNE map of the tung data (perplexity = 200)" width="90%" />
<p class="caption">
Figure 7.22: tSNE map of the tung data (perplexity = 200)
</p>
</div>
</div>
</div>
<div id="section-62" class="section level3">
<h3><span class="header-section-number">7.3.4</span> 大作业</h3>
<p>使用Blischak数据的read counts数据完成相同的分析，使用<code>tung/reads.rds</code>文件导入reads的SCE对象。完成后的结果与我们相比较(下一章)。</p>
</div>
</div>
<div id="reads-2" class="section level2">
<h2><span class="header-section-number">7.4</span> Reads数据可视化</h2>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scater)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
reads &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/reads.rds&quot;</span>)
reads.qc &lt;-<span class="st"> </span>reads[<span class="kw">rowData</span>(reads)<span class="op">$</span>use, <span class="kw">colData</span>(reads)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(reads.qc)<span class="op">$</span>is_feature_control</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;counts&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-before-qc-reads1"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-pca-before-qc-reads1-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.23: PCA plot of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-before-qc-reads2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-pca-before-qc-reads2-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.24: PCA plot of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads.qc[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-pca-after-qc-reads"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-pca-after-qc-reads-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.25: PCA plot of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    reads[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">130</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-before-qc-reads"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-tsne-before-qc-reads-1.png" alt="tSNE map of the tung data" width="90%" />
<p class="caption">
Figure 7.26: tSNE map of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    reads.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">130</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc-reads"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-tsne-after-qc-reads-1.png" alt="tSNE map of the tung data" width="90%" />
<p class="caption">
Figure 7.27: tSNE map of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    reads.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">10</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc-exercise3-1"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-tsne-after-qc-exercise2-1-1.png" alt="tSNE map of the tung data (perplexity = 10)" width="90%" />
<p class="caption">
Figure 7.28: tSNE map of the tung data (perplexity = 10)
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123456</span>)
tmp &lt;-<span class="st"> </span><span class="kw">runTSNE</span>(
    reads.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">perplexity =</span> <span class="dv">200</span>
)
<span class="kw">plotTSNE</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:expr-overview-tsne-after-qc-exercise3-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-overview-reads_files/figure-html/expr-overview-tsne-after-qc-exercise2-2-1.png" alt="tSNE map of the tung data (perplexity = 200)" width="90%" />
<p class="caption">
Figure 7.29: tSNE map of the tung data (perplexity = 200)
</p>
</div>
</div>
<div id="identifying-confounding-factors" class="section level2">
<h2><span class="header-section-number">7.5</span> Identifying confounding factors</h2>
<div id="introduction" class="section level3">
<h3><span class="header-section-number">7.5.1</span> Introduction</h3>
<p>There is a large number of potential confounders, artifacts and biases in sc-RNA-seq data. One of the main challenges in analyzing scRNA-seq data stems from the fact that it is difficult to carry out a true technical replicate (why?) to distinguish biological and technical variability. In the previous chapters we considered batch effects and in this chapter we will continue to explore how experimental artifacts can be identified and removed. We will continue using the <code>scater</code> package since it provides a set of methods specifically for quality control of experimental and explanatory variables. Moreover, we will continue to work with the Blischak data that was used in the previous chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scater, <span class="dt">quietly =</span> <span class="ot">TRUE</span>)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
umi &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/umi.rds&quot;</span>)
umi.qc &lt;-<span class="st"> </span>umi[<span class="kw">rowData</span>(umi)<span class="op">$</span>use, <span class="kw">colData</span>(umi)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(umi.qc)<span class="op">$</span>is_feature_control</code></pre>
<p>The <code>umi.qc</code> dataset contains filtered cells and genes. Our next step is to explore technical drivers of variability in the data to inform data normalisation before downstream analysis.</p>
</div>
<div id="correlations-with-pcs" class="section level3">
<h3><span class="header-section-number">7.5.2</span> Correlations with PCs</h3>
<p>Let’s first look again at the PCA plot of the QCed dataset:</p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi.qc[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:confound-pca"></span>
<img src="07exprs-overview_files/figure-html/confound-pca-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.30: PCA plot of the tung data
</p>
</div>
<p><code>scater</code> allows one to identify principal components that correlate with experimental and QC variables of interest (it ranks principle components by <span class="math inline">\(R^2\)</span> from a linear model regressing PC value against the variable of interest).</p>
<p>Let’s test whether some of the variables correlate with any of the PCs.</p>
<div id="detected-genes" class="section level4">
<h4><span class="header-section-number">7.5.2.1</span> Detected genes</h4>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(umi.qc) &lt;-<span class="st"> </span><span class="kw">assay</span>(umi.qc, <span class="st">&quot;logcounts_raw&quot;</span>)
<span class="kw">plotExplanatoryPCs</span>(
  umi.qc[endog_genes, ],
  <span class="dt">variables =</span> <span class="st">&quot;total_features_by_counts&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:confound-find-pcs-total-features"></span>
<img src="07exprs-overview_files/figure-html/confound-find-pcs-total-features-1.png" alt="PC correlation with the number of detected genes" width="90%" />
<p class="caption">
Figure 7.31: PC correlation with the number of detected genes
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(umi.qc) &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<p>Indeed, we can see that <code>PC1</code> can be almost completely explained by the number of detected genes. In fact, it was also visible on the PCA plot above. This is a well-known issue in scRNA-seq and was described <a href="http://biorxiv.org/content/early/2015/12/27/025528">here</a>.</p>
</div>
</div>
<div id="explanatory-variables" class="section level3">
<h3><span class="header-section-number">7.5.3</span> Explanatory variables</h3>
<p><code>scater</code> can also compute the marginal <span class="math inline">\(R^2\)</span> for each variable when fitting a linear model regressing expression values for each gene against just that variable, and display a density plot of the gene-wise marginal <span class="math inline">\(R^2\)</span> values for the variables.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExplanatoryVariables</span>(
    umi.qc[endog_genes, ],
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">variables =</span> <span class="kw">c</span>(
        <span class="st">&quot;total_features_by_counts&quot;</span>,
        <span class="st">&quot;total_counts&quot;</span>,
        <span class="st">&quot;batch&quot;</span>,
        <span class="st">&quot;individual&quot;</span>,
        <span class="st">&quot;pct_counts_ERCC&quot;</span>,
        <span class="st">&quot;pct_counts_MT&quot;</span>
    )
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:confound-find-expl-vars"></span>
<img src="07exprs-overview_files/figure-html/confound-find-expl-vars-1.png" alt="Explanatory variables" width="90%" />
<p class="caption">
Figure 7.32: Explanatory variables
</p>
</div>
<p>This analysis indicates that the number of detected genes (again) and also the sequencing depth (number of counts) have substantial explanatory power for many genes, so these variables are good candidates for conditioning out in a normalisation step, or including in downstream statistical models. Expression of ERCCs also appears to be an important explanatory variable and one notable feature of the above plot is that batch explains more than individual. What does that tell us about the technical and biological variability of the data?</p>
</div>
<div id="other-confounders" class="section level3">
<h3><span class="header-section-number">7.5.4</span> Other confounders</h3>
<p>In addition to correcting for batch, there are other factors that one
may want to compensate for. As with batch correction, these
adjustments require extrinsic information. One popular method is
<a href="https://github.com/PMBio/scLVM">scLVM</a> which allows you to identify
and subtract the effect from processes such as cell-cycle or
apoptosis.</p>
<p>In addition, protocols may differ in terms of their coverage of each transcript,
their bias based on the average content of <strong>A/T</strong> nucleotides, or their ability to capture short transcripts.
Ideally, we would like to compensate for all of these differences and biases.</p>
</div>
<div id="exercise" class="section level3">
<h3><span class="header-section-number">7.5.5</span> Exercise</h3>
<p>Perform the same analysis with read counts of the Blischak data. Use <code>tung/reads.rds</code> file to load the reads SCESet object. Once you have finished please compare your results to ours (next chapter).</p>
</div>
</div>
<div id="identifying-confounding-factors-reads" class="section level2">
<h2><span class="header-section-number">7.6</span> Identifying confounding factors (Reads)</h2>
<div class="figure" style="text-align: center"><span id="fig:confound-pca-reads"></span>
<img src="07exprs-overview_files/figure-html/confound-pca-reads-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.33: PCA plot of the tung data
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:confound-find-pcs-total-features-reads"></span>
<img src="07exprs-overview_files/figure-html/confound-find-pcs-total-features-reads-1.png" alt="PC correlation with the number of detected genes" width="90%" />
<p class="caption">
Figure 7.34: PC correlation with the number of detected genes
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:confound-find-expl-vars-reads"></span>
<img src="07exprs-overview_files/figure-html/confound-find-expl-vars-reads-1.png" alt="Explanatory variables" width="90%" />
<p class="caption">
Figure 7.35: Explanatory variables
</p>
</div>
</div>
<div id="normalization-theory" class="section level2">
<h2><span class="header-section-number">7.7</span> Normalization theory</h2>
<div id="introduction-1" class="section level3">
<h3><span class="header-section-number">7.7.1</span> Introduction</h3>
<p>In the previous chapter we identified important confounding factors and explanatory variables. <code>scater</code> allows one to account for these variables in subsequent statistical models or to condition them out using <code>normaliseExprs()</code>, if so desired. This can be done by providing a design matrix to <code>normaliseExprs()</code>. We are not covering this topic here, but you can try to do it yourself as an exercise.</p>
<p>Instead we will explore how simple size-factor normalisations correcting for library size can remove the effects of some of the confounders and explanatory variables.</p>
</div>
<div id="library-size" class="section level3">
<h3><span class="header-section-number">7.7.2</span> Library size</h3>
<p>Library sizes vary because scRNA-seq data is often sequenced on highly multiplexed platforms the total reads which are derived from each cell may differ substantially. Some quantification methods
(eg. <a href="http://cole-trapnell-lab.github.io/cufflinks/"><code>Cufflinks</code></a>, <a href="http://deweylab.github.io/RSEM/"><code>RSEM</code></a>) incorporated library size when determining gene expression estimates thus do not require this normalization.</p>
<p>However, if another quantification method was used then library size must be corrected for by multiplying or dividing each column of the expression matrix by a “normalization factor” which is an estimate of the library size relative to the other cells. Many methods to correct for library size have been developped for bulk RNA-seq and can be equally applied to scRNA-seq (eg. <strong>UQ</strong>, <strong>SF</strong>, <strong>CPM</strong>, <strong>RPKM</strong>, <strong>FPKM</strong>, <strong>TPM</strong>).</p>
</div>
<div id="normalisations" class="section level3">
<h3><span class="header-section-number">7.7.3</span> Normalisations</h3>
<div id="cpm" class="section level4">
<h4><span class="header-section-number">7.7.3.1</span> CPM</h4>
<p>The simplest way to normalize this data is to convert it to counts per
million (<strong>CPM</strong>) by dividing each column by its total then multiplying by
1,000,000. Note that spike-ins should be excluded from the
calculation of total expression in order to correct for total cell RNA
content, therefore we will only use endogenous genes. Example of a <strong>CPM</strong> function in <code>R</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">calc_cpm &lt;-
<span class="cf">function</span> (expr_mat, <span class="dt">spikes =</span> <span class="ot">NULL</span>) 
{
    norm_factor &lt;-<span class="st"> </span><span class="kw">colSums</span>(expr_mat[<span class="op">-</span>spikes, ])
    <span class="kw">return</span>(<span class="kw">t</span>(<span class="kw">t</span>(expr_mat)<span class="op">/</span>norm_factor)) <span class="op">*</span><span class="st"> </span><span class="dv">10</span><span class="op">^</span><span class="dv">6</span>
}</code></pre>
<p>One potential drawback of <strong>CPM</strong> is if your sample contains genes that are both very highly expressed and differentially expressed across the cells. In this case, the total molecules in the cell may depend of whether such genes are on/off in the cell and normalizing by total molecules may hide the differential expression of those genes and/or falsely create differential expression for the remaining genes.</p>
<p><strong>Note</strong> <strong>RPKM</strong>, <strong>FPKM</strong> and <strong>TPM</strong> are variants on <strong>CPM</strong> which further adjust counts by the length of the respective gene/transcript.</p>
<p>To deal with this potentiality several other measures were devised.</p>
</div>
<div id="rle-sf" class="section level4">
<h4><span class="header-section-number">7.7.3.2</span> RLE (SF)</h4>
<p>The <strong>size factor (SF)</strong> was proposed and popularized by DESeq <span class="citation">(Anders and Huber <a href="#ref-Anders2010-jr">2010</a>)</span>. First the geometric mean of each gene across all cells is calculated. The size factor for each cell is the median across genes of the ratio of the expression to the gene’s geometric mean. A drawback to this method is that since it uses the geometric mean only genes with non-zero expression values across all cells can be used in its calculation, making it unadvisable for large low-depth scRNASeq experiments. <code>edgeR</code> &amp; <code>scater</code> call this method <strong>RLE</strong> for “relative log expression”. Example of a <strong>SF</strong> function in <code>R</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">calc_sf &lt;-
<span class="cf">function</span> (expr_mat, <span class="dt">spikes =</span> <span class="ot">NULL</span>) 
{
    geomeans &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">rowMeans</span>(<span class="kw">log</span>(expr_mat[<span class="op">-</span>spikes, ])))
    SF &lt;-<span class="st"> </span><span class="cf">function</span>(cnts) {
        <span class="kw">median</span>((cnts<span class="op">/</span>geomeans)[(<span class="kw">is.finite</span>(geomeans) <span class="op">&amp;</span><span class="st"> </span>geomeans <span class="op">&gt;</span><span class="st"> </span>
<span class="st">            </span><span class="dv">0</span>)])
    }
    norm_factor &lt;-<span class="st"> </span><span class="kw">apply</span>(expr_mat[<span class="op">-</span>spikes, ], <span class="dv">2</span>, SF)
    <span class="kw">return</span>(<span class="kw">t</span>(<span class="kw">t</span>(expr_mat)<span class="op">/</span>norm_factor))
}</code></pre>
</div>
<div id="uq" class="section level4">
<h4><span class="header-section-number">7.7.3.3</span> UQ</h4>
<p>The <strong>upperquartile (UQ)</strong> was proposed by <span class="citation">(Bullard et al. <a href="#ref-Bullard2010-eb">2010</a>)</span>. Here each column is divided by the 75% quantile of the counts for each library. Often the calculated quantile is scaled by the median across cells to keep the absolute level of expression relatively consistent. A drawback to this method is that for low-depth scRNASeq experiments the large number of undetected genes may result in the 75% quantile being zero (or close to it). This limitation can be overcome by generalizing the idea and using a higher quantile (eg. the 99% quantile is the default in scater) or by excluding zeros prior to calculating the 75% quantile. Example of a <strong>UQ</strong> function in <code>R</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">calc_uq &lt;-
<span class="cf">function</span> (expr_mat, <span class="dt">spikes =</span> <span class="ot">NULL</span>) 
{
    UQ &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
        <span class="kw">quantile</span>(x[x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>], <span class="fl">0.75</span>)
    }
    uq &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">apply</span>(expr_mat[<span class="op">-</span>spikes, ], <span class="dv">2</span>, UQ))
    norm_factor &lt;-<span class="st"> </span>uq<span class="op">/</span><span class="kw">median</span>(uq)
    <span class="kw">return</span>(<span class="kw">t</span>(<span class="kw">t</span>(expr_mat)<span class="op">/</span>norm_factor))
}</code></pre>
</div>
<div id="tmm" class="section level4">
<h4><span class="header-section-number">7.7.3.4</span> TMM</h4>
<p>Another method is called <strong>TMM</strong> is the weighted trimmed mean of M-values (to the reference) proposed by <span class="citation">(Robinson and Oshlack <a href="#ref-Robinson2010-hz">2010</a>)</span>. The M-values in question are the gene-wise log2 fold changes between individual cells. One cell is used as the reference then the M-values for each other cell is calculated compared to this reference. These values are then trimmed by removing the top and bottom ~30%, and the average of the remaining values is calculated by weighting them to account for the effect of the log scale on variance. Each non-reference cell is multiplied by the calculated factor. Two potential issues with this method are insufficient non-zero genes left after trimming, and the assumption that most genes are not differentially expressed.</p>
</div>
<div id="scran" class="section level4">
<h4><span class="header-section-number">7.7.3.5</span> scran</h4>
<p><code>scran</code> package implements a variant on <strong>CPM</strong> specialized for single-cell data <span class="citation">(L. Lun, Bach, and Marioni <a href="#ref-L_Lun2016-pq">2016</a>)</span>. Briefly this method deals with the problem of vary large numbers of zero values per cell by pooling cells together calculating a normalization factor (similar to <strong>CPM</strong>) for the sum of each pool. Since each cell is found in many different pools, cell-specific factors can be deconvoluted from the collection of pool-specific factors using linear algebra.</p>
</div>
<div id="downsampling" class="section level4">
<h4><span class="header-section-number">7.7.3.6</span> Downsampling</h4>
<p>A final way to correct for library size is to downsample the expression matrix so that each cell has approximately the same total number of molecules. The benefit of this method is that zero values will be introduced by the down sampling thus eliminating any biases due to differing numbers of detected genes. However, the major drawback is that the process is not deterministic so each time the downsampling is run the resulting expression matrix is slightly different. Thus, often analyses must be run on multiple downsamplings to ensure results are robust. Example of a <strong>downsampling</strong> function in <code>R</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">Down_Sample_Matrix &lt;-
<span class="cf">function</span> (expr_mat) 
{
    min_lib_size &lt;-<span class="st"> </span><span class="kw">min</span>(<span class="kw">colSums</span>(expr_mat))
    down_sample &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
        prob &lt;-<span class="st"> </span>min_lib_size<span class="op">/</span><span class="kw">sum</span>(x)
        <span class="kw">return</span>(<span class="kw">unlist</span>(<span class="kw">lapply</span>(x, <span class="cf">function</span>(y) {
            <span class="kw">rbinom</span>(<span class="dv">1</span>, y, prob)
        })))
    }
    down_sampled_mat &lt;-<span class="st"> </span><span class="kw">apply</span>(expr_mat, <span class="dv">2</span>, down_sample)
    <span class="kw">return</span>(down_sampled_mat)
}</code></pre>
</div>
</div>
<div id="effectiveness" class="section level3">
<h3><span class="header-section-number">7.7.4</span> Effectiveness</h3>
<p>to compare the efficiency of different normalization methods we will use visual inspection of <code>PCA</code> plots and calculation of cell-wise <em>relative log expression</em> via <code>scater</code>’s <code>plotRLE()</code> function. Namely, cells with many (few) reads have higher (lower) than median expression for most genes resulting in a positive (negative) <em>RLE</em> across the cell, whereas normalized cells have an <em>RLE</em> close to zero. Example of a <em>RLE</em> function in <code>R</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">calc_cell_RLE &lt;-
<span class="cf">function</span> (expr_mat, <span class="dt">spikes =</span> <span class="ot">NULL</span>) 
{
    RLE_gene &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
        <span class="cf">if</span> (<span class="kw">median</span>(<span class="kw">unlist</span>(x)) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
            <span class="kw">log</span>((x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">/</span>(<span class="kw">median</span>(<span class="kw">unlist</span>(x)) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>))<span class="op">/</span><span class="kw">log</span>(<span class="dv">2</span>)
        }
        <span class="cf">else</span> {
            <span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dt">times =</span> <span class="kw">length</span>(x))
        }
    }
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(spikes)) {
        RLE_matrix &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(expr_mat[<span class="op">-</span>spikes, ], <span class="dv">1</span>, RLE_gene))
    }
    <span class="cf">else</span> {
        RLE_matrix &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(expr_mat, <span class="dv">1</span>, RLE_gene))
    }
    cell_RLE &lt;-<span class="st"> </span><span class="kw">apply</span>(RLE_matrix, <span class="dv">2</span>, median, <span class="dt">na.rm =</span> T)
    <span class="kw">return</span>(cell_RLE)
}</code></pre>
<p><strong>Note</strong> The <strong>RLE</strong>, <strong>TMM</strong>, and <strong>UQ</strong> size-factor methods were developed for bulk RNA-seq data and, depending on the experimental context, may not be appropriate for single-cell RNA-seq data, as their underlying assumptions may be problematically violated.</p>
<p><strong>Note</strong> <code>scater</code> acts as a wrapper for the <code>calcNormFactors</code> function from <code>edgeR</code> which implements several library size normalization methods making it easy to apply any of these methods to our data.</p>
<p><strong>Note</strong> <code>edgeR</code> makes extra adjustments to some of the normalization methods which may result in somewhat different results than if the original methods are followed exactly, e.g. edgeR’s and scater’s “RLE” method which is based on the “size factor” used by <a href="http://bioconductor.org/packages/DESeq">DESeq</a> may give different results to the <code>estimateSizeFactorsForMatrix</code> method in the <code>DESeq</code>/<code>DESeq2</code> packages. In addition, some versions of <code>edgeR</code> will not calculate the normalization factors correctly unless <code>lib.size</code> is set at 1 for all cells.</p>
<p><strong>Note</strong> For <strong>CPM</strong> normalisation we use <code>scater</code>’s <code>calculateCPM()</code> function. For <strong>RLE</strong>, <strong>UQ</strong> and <strong>TMM</strong> we used to use <code>scater</code>’s <code>normaliseExprs()</code> function (it is deprecated now and therefore we removed the corresponding subchapters). For <strong>scran</strong> we use <code>scran</code> package to calculate size factors (it also operates on <code>SingleCellExperiment</code> class) and <code>scater</code>’s <code>normalize()</code> to normalise the data. All these normalization functions save the results to the <code>logcounts</code> slot of the <code>SCE</code> object. For <strong>downsampling</strong> we use our own functions shown above.</p>
</div>
</div>
<div id="normalization-practice-umi" class="section level2">
<h2><span class="header-section-number">7.8</span> Normalization practice (UMI)</h2>
<p>We will continue to work with the <code>tung</code> data that was used in the previous chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(scran)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)
umi &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/umi.rds&quot;</span>)
umi.qc &lt;-<span class="st"> </span>umi[<span class="kw">rowData</span>(umi)<span class="op">$</span>use, <span class="kw">colData</span>(umi)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(umi.qc)<span class="op">$</span>is_feature_control</code></pre>
<div id="raw" class="section level3">
<h3><span class="header-section-number">7.8.1</span> Raw</h3>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi.qc[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-raw"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-raw-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.36: PCA plot of the tung data
</p>
</div>
</div>
<div id="cpm-1" class="section level3">
<h3><span class="header-section-number">7.8.2</span> CPM</h3>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(umi.qc) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateCPM</span>(umi.qc, <span class="dt">use_size_factors =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">plotPCA</span>(
    umi.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-cpm"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-cpm-1.png" alt="PCA plot of the tung data after CPM normalisation" width="90%" />
<p class="caption">
Figure 7.37: PCA plot of the tung data after CPM normalisation
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-cpm1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-cpm-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.38: Cell-wise RLE of the tung data
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-cpm2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-cpm-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.39: Cell-wise RLE of the tung data
</p>
</div>
</div>
<div id="scran-1" class="section level3">
<h3><span class="header-section-number">7.8.3</span> scran</h3>
<pre class="sourceCode r"><code class="sourceCode r">qclust &lt;-<span class="st"> </span><span class="kw">quickCluster</span>(umi.qc, <span class="dt">min.size =</span> <span class="dv">30</span>)</code></pre>
<pre><code>## Warning: Setting &#39;use.ranks=TRUE&#39; for the old defaults.
## Set &#39;use.ranks=FALSE&#39; for the new defaults.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">umi.qc &lt;-<span class="st"> </span><span class="kw">computeSumFactors</span>(umi.qc, <span class="dt">sizes =</span> <span class="dv">15</span>, <span class="dt">clusters =</span> qclust)
umi.qc &lt;-<span class="st"> </span><span class="kw">normalize</span>(umi.qc)</code></pre>
<pre><code>## Warning in .get_all_sf_sets(object): spike-in set &#39;ERCC&#39; should have its
## own size factors</code></pre>
<pre><code>## Warning in .get_all_sf_sets(object): spike-in set &#39;MT&#39; should have its own
## size factors</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    umi.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-lsf"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-lsf-1.png" alt="PCA plot of the tung data after LSF normalisation" width="90%" />
<p class="caption">
Figure 7.40: PCA plot of the tung data after LSF normalisation
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    umi.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-scran1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-scran-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.41: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    umi.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-scran2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-scran-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.42: Cell-wise RLE of the tung data
</p>
</div>
<p>scran sometimes calculates negative or zero size factors. These will completely distort the normalized expression matrix.
We can check the size factors scran has computed like so:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">sizeFactors</span>(umi.qc))</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.4832  0.7812  0.9535  1.0000  1.1469  3.2595</code></pre>
<p>For this dataset all the size factors are reasonable so we are done. If you find scran has calculated negative size factors try increasing the cluster and pool sizes until they are all positive.</p>
</div>
<div id="downsampling-1" class="section level3">
<h3><span class="header-section-number">7.8.4</span> Downsampling</h3>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(umi.qc) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">Down_Sample_Matrix</span>(<span class="kw">counts</span>(umi.qc)) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">plotPCA</span>(
    umi.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-downsample"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-downsample-1.png" alt="PCA plot of the tung data after downsampling" width="90%" />
<p class="caption">
Figure 7.43: PCA plot of the tung data after downsampling
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    umi.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-downsample1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-downsample-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.44: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    umi.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-downsample2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-downsample-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.45: Cell-wise RLE of the tung data
</p>
</div>
</div>
<div id="normalisation-for-genetranscript-length" class="section level3">
<h3><span class="header-section-number">7.8.5</span> Normalisation for gene/transcript length</h3>
<p>Some methods combine library size and fragment/gene length normalization such as:</p>
<ul>
<li><strong>RPKM</strong> - Reads Per Kilobase Million (for single-end sequencing)</li>
<li><strong>FPKM</strong> - Fragments Per Kilobase Million (same as <strong>RPKM</strong> but for paired-end sequencing, makes sure that paired ends mapped to the same fragment are not counted twice)</li>
<li><strong>TPM</strong> - Transcripts Per Kilobase Million (same as <strong>RPKM</strong>, but the order of normalizations is reversed - length first and sequencing depth second)</li>
</ul>
<p>These methods are not applicable to our dataset since the end
of the transcript which contains the UMI was preferentially
sequenced. Furthermore in general these should only be calculated
using appropriate quantification software from aligned BAM files not
from read counts since often only a portion of the entire
gene/transcript is sequenced, not the entire length. If in doubt check
for a relationship between gene/transcript length and expression level.</p>
<p>However, here we show how these normalisations can be calculated using <code>scater</code>. First, we need to find the effective transcript length in Kilobases. However, our dataset containes only gene IDs, therefore we will be using the gene lengths instead of transcripts. <code>scater</code> uses the <a href="https://bioconductor.org/packages/release/bioc/html/biomaRt.html">biomaRt</a> package, which allows one to annotate genes by other attributes:</p>
<pre class="sourceCode r"><code class="sourceCode r">umi.qc &lt;-<span class="st"> </span><span class="kw">getBMFeatureAnnos</span>(
    umi.qc,
    <span class="dt">filters =</span> <span class="st">&quot;ensembl_gene_id&quot;</span>, 
    <span class="dt">attributes =</span> <span class="kw">c</span>(
        <span class="st">&quot;ensembl_gene_id&quot;</span>,
        <span class="st">&quot;hgnc_symbol&quot;</span>,
        <span class="st">&quot;chromosome_name&quot;</span>,
        <span class="st">&quot;start_position&quot;</span>,
        <span class="st">&quot;end_position&quot;</span>
    ), 
    <span class="dt">biomart =</span> <span class="st">&quot;ENSEMBL_MART_ENSEMBL&quot;</span>, 
    <span class="dt">dataset =</span> <span class="st">&quot;hsapiens_gene_ensembl&quot;</span>,
    <span class="dt">host =</span> <span class="st">&quot;www.ensembl.org&quot;</span>
)

<span class="co"># If you have mouse data, change the arguments based on this example:</span>
<span class="co"># getBMFeatureAnnos(</span>
<span class="co">#     object,</span>
<span class="co">#     filters = &quot;ensembl_transcript_id&quot;,</span>
<span class="co">#     attributes = c(</span>
<span class="co">#         &quot;ensembl_transcript_id&quot;,</span>
<span class="co">#         &quot;ensembl_gene_id&quot;, </span>
<span class="co">#         &quot;mgi_symbol&quot;,</span>
<span class="co">#         &quot;chromosome_name&quot;,</span>
<span class="co">#         &quot;transcript_biotype&quot;,</span>
<span class="co">#         &quot;transcript_start&quot;,</span>
<span class="co">#         &quot;transcript_end&quot;,</span>
<span class="co">#         &quot;transcript_count&quot;</span>
<span class="co">#     ),</span>
<span class="co">#     biomart = &quot;ENSEMBL_MART_ENSEMBL&quot;,</span>
<span class="co">#     dataset = &quot;mmusculus_gene_ensembl&quot;,</span>
<span class="co">#     host = &quot;www.ensembl.org&quot;</span>
<span class="co"># )</span></code></pre>
<p>Some of the genes were not annotated, therefore we filter them out:</p>
<pre class="sourceCode r"><code class="sourceCode r">umi.qc.ann &lt;-<span class="st"> </span>umi.qc[<span class="op">!</span><span class="kw">is.na</span>(<span class="kw">rowData</span>(umi.qc)<span class="op">$</span>ensembl_gene_id), ]</code></pre>
<p>Now we compute the total gene length in Kilobases by using the <code>end_position</code> and <code>start_position</code> fields:</p>
<pre class="sourceCode r"><code class="sourceCode r">eff_length &lt;-<span class="st"> </span>
<span class="st">    </span><span class="kw">abs</span>(<span class="kw">rowData</span>(umi.qc.ann)<span class="op">$</span>end_position <span class="op">-</span><span class="st"> </span><span class="kw">rowData</span>(umi.qc.ann)<span class="op">$</span>start_position) <span class="op">/</span><span class="st"> </span><span class="dv">1000</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(eff_length, <span class="kw">rowMeans</span>(<span class="kw">counts</span>(umi.qc.ann)))</code></pre>
<div class="figure" style="text-align: center"><span id="fig:length-vs-mean-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-norm_files/figure-html/length-vs-mean-1.png" alt="Gene length vs Mean Expression for the raw data" width="90%" />
<p class="caption">
Figure 7.46: Gene length vs Mean Expression for the raw data
</p>
</div>
<p>There is no relationship between gene length and mean expression so __FPKM__s &amp; __TPM__s are inappropriate for this dataset.
But we will demonstrate them anyway.</p>
<p><strong>Note</strong> Here calculate the total gene length instead of the total exon length. Many genes will contain lots of introns so their <code>eff_length</code> will be very different from what we have calculated. Please consider our calculation as approximation. If you want to use the total exon lengths, please refer to <a href="https://www.biostars.org/p/83901/">this page</a>.</p>
<p>Now we are ready to perform the normalisations:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tpm</span>(umi.qc.ann) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateTPM</span>(umi.qc.ann, eff_length) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<p>Plot the results as a PCA plot:</p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi.qc.ann,
  <span class="dt">exprs_values =</span> <span class="st">&quot;tpm&quot;</span>,
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-fpkm-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-norm_files/figure-html/norm-pca-fpkm-1.png" alt="PCA plot of the tung data after TPM normalisation" width="90%" />
<p class="caption">
Figure 7.47: PCA plot of the tung data after TPM normalisation
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tpm</span>(umi.qc.ann) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateFPKM</span>(umi.qc.ann, eff_length) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  umi.qc.ann,
  <span class="dt">exprs_values =</span> <span class="st">&quot;tpm&quot;</span>,
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span><span class="kw">include_graphics</span>(<span class="st">&quot;https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-norm_files/figure-html/norm-pca-tpm-1.png&quot;</span>)</code></pre>
<p><strong>Note</strong> The <code>PCA</code> looks for differences between cells. Gene length is the same across cells for each gene thus <strong>FPKM</strong> is almost identical to the <strong>CPM</strong> plot (it is just rotated) since it performs <strong>CPM</strong> first then normalizes gene length. Whereas, <strong>TPM</strong> is different because it weights genes by their length before performing <strong>CPM</strong>.</p>
</div>
<div id="exercise-1" class="section level3">
<h3><span class="header-section-number">7.8.6</span> Exercise</h3>
<p>Perform the same analysis with read counts of the <code>tung</code> data. Use <code>tung/reads.rds</code> file to load the reads <code>SCE</code> object. Once you have finished please compare your results to ours (next chapter).</p>
</div>
</div>
<div id="normalization-practice-reads" class="section level2">
<h2><span class="header-section-number">7.9</span> Normalization practice (Reads)</h2>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(scran)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)
<span class="kw">library</span>(knitr)
opts_chunk<span class="op">$</span><span class="kw">set</span>(<span class="dt">out.width=</span><span class="st">&#39;90%&#39;</span>, <span class="dt">fig.align =</span> <span class="st">&#39;center&#39;</span>, <span class="dt">echo=</span><span class="ot">FALSE</span>)
reads &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/reads.rds&quot;</span>)
reads.qc &lt;-<span class="st"> </span>reads[<span class="kw">rowData</span>(reads)<span class="op">$</span>use, <span class="kw">colData</span>(reads)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(reads.qc)<span class="op">$</span>is_feature_control</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads.qc[endog_genes, ],
  <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-raw-reads"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-raw-reads-1.png" alt="PCA plot of the tung data" width="90%" />
<p class="caption">
Figure 7.48: PCA plot of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(reads.qc) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateCPM</span>(reads.qc, <span class="dt">use_size_factors =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">plotPCA</span>(
    reads.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-cpm-reads"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-cpm-reads-1.png" alt="PCA plot of the tung data after CPM normalisation" width="90%" />
<p class="caption">
Figure 7.49: PCA plot of the tung data after CPM normalisation
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-cpm-reads1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-cpm-reads-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.50: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-cpm-reads2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-cpm-reads-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.51: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">qclust &lt;-<span class="st"> </span><span class="kw">quickCluster</span>(reads.qc, <span class="dt">min.size =</span> <span class="dv">30</span>)</code></pre>
<pre><code>## Warning: Setting &#39;use.ranks=TRUE&#39; for the old defaults.
## Set &#39;use.ranks=FALSE&#39; for the new defaults.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads.qc &lt;-<span class="st"> </span><span class="kw">computeSumFactors</span>(reads.qc, <span class="dt">sizes =</span> <span class="dv">15</span>, <span class="dt">clusters =</span> qclust)
reads.qc &lt;-<span class="st"> </span><span class="kw">normalize</span>(reads.qc)</code></pre>
<pre><code>## Warning in .get_all_sf_sets(object): spike-in set &#39;ERCC&#39; should have its
## own size factors</code></pre>
<pre><code>## Warning in .get_all_sf_sets(object): spike-in set &#39;MT&#39; should have its own
## size factors</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    reads.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-lsf-umi"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-lsf-umi-1.png" alt="PCA plot of the tung data after LSF normalisation" width="90%" />
<p class="caption">
Figure 7.52: PCA plot of the tung data after LSF normalisation
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-scran-reads1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-scran-reads-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.53: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-scran-reads2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-scran-reads-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.54: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logcounts</span>(reads.qc) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">Down_Sample_Matrix</span>(<span class="kw">counts</span>(reads.qc)) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="kw">plotPCA</span>(
    reads.qc[endog_genes, ],
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-downsample-reads"></span>
<img src="07exprs-overview_files/figure-html/norm-pca-downsample-reads-1.png" alt="PCA plot of the tung data after downsampling" width="90%" />
<p class="caption">
Figure 7.55: PCA plot of the tung data after downsampling
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts_raw&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-downsample-reads1"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-downsample-reads-1.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.56: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotRLE</span>(
    reads.qc[endog_genes, ], 
    <span class="dt">exprs_values =</span> <span class="st">&quot;logcounts&quot;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-ours-rle-downsample-reads2"></span>
<img src="07exprs-overview_files/figure-html/norm-ours-rle-downsample-reads-2.png" alt="Cell-wise RLE of the tung data" width="90%" />
<p class="caption">
Figure 7.57: Cell-wise RLE of the tung data
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r">reads.qc &lt;-<span class="st"> </span><span class="kw">getBMFeatureAnnos</span>(
    reads.qc,
    <span class="dt">filters =</span> <span class="st">&quot;ensembl_gene_id&quot;</span>, 
    <span class="dt">attributes =</span> <span class="kw">c</span>(
        <span class="st">&quot;ensembl_gene_id&quot;</span>,
        <span class="st">&quot;hgnc_symbol&quot;</span>,
        <span class="st">&quot;chromosome_name&quot;</span>,
        <span class="st">&quot;start_position&quot;</span>,
        <span class="st">&quot;end_position&quot;</span>
    ), 
    <span class="dt">biomart =</span> <span class="st">&quot;ENSEMBL_MART_ENSEMBL&quot;</span>, 
    <span class="dt">dataset =</span> <span class="st">&quot;hsapiens_gene_ensembl&quot;</span>,
    <span class="dt">host =</span> <span class="st">&quot;www.ensembl.org&quot;</span>
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads.qc.ann &lt;-<span class="st"> </span>reads.qc[<span class="op">!</span><span class="kw">is.na</span>(<span class="kw">rowData</span>(reads.qc)<span class="op">$</span>ensembl_gene_id), ]</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">eff_length &lt;-<span class="st"> </span>
<span class="st">    </span><span class="kw">abs</span>(<span class="kw">rowData</span>(reads.qc.ann)<span class="op">$</span>end_position <span class="op">-</span><span class="st"> </span><span class="kw">rowData</span>(reads.qc.ann)<span class="op">$</span>start_position) <span class="op">/</span><span class="st"> </span><span class="dv">1000</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tpm</span>(reads.qc.ann) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateTPM</span>(reads.qc.ann, eff_length) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads.qc.ann,
  <span class="dt">exprs_values =</span> <span class="st">&quot;tpm&quot;</span>,
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:norm-pca-tpm-reads-2"></span>
<img src="https://scrnaseq-course.cog.sanger.ac.uk/website/exprs-norm-reads_files/figure-html/norm-pca-tpm-reads-1.png" alt="PCA plot of the tung data after TPM normalisation" width="90%" />
<p class="caption">
Figure 7.58: PCA plot of the tung data after TPM normalisation
</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tpm</span>(reads.qc.ann) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">calculateFPKM</span>(reads.qc.ann, eff_length) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
  reads.qc.ann,
  <span class="dt">exprs_values =</span> <span class="st">&quot;tpm&quot;</span>,
)
<span class="kw">plotPCA</span>(
    tmp,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
</div>
<div id="dealing-with-confounders" class="section level2">
<h2><span class="header-section-number">7.10</span> Dealing with confounders</h2>
<div id="introduction-2" class="section level3">
<h3><span class="header-section-number">7.10.1</span> Introduction</h3>
<p>In the previous chapter we normalized for library size, effectively removing it as a confounder. Now we will consider removing other less well defined confounders from our data. Technical confounders (aka batch effects) can arise from difference in reagents, isolation methods, the lab/experimenter who performed the experiment, even which day/time the experiment was performed. Accounting for technical confounders, and batch effects particularly, is a large topic that also involves principles of experimental design. Here we address approaches that can be taken to account for confounders when the experimental design is appropriate.</p>
<p>Fundamentally, accounting for technical confounders involves identifying and, ideally, removing sources of variation in the expression data that are not related to (i.e. are confounding) the biological signal of interest. Various approaches exist, some of which use spike-in or housekeeping genes, and some of which use endogenous genes.</p>
<div id="advantages-and-disadvantages-of-using-spike-ins-to-remove-confounders" class="section level4">
<h4><span class="header-section-number">7.10.1.1</span> Advantages and disadvantages of using spike-ins to remove confounders</h4>
<p>The use of spike-ins as control genes is appealing, since the same amount of ERCC (or other) spike-in was added to each cell in our experiment. In principle, all the variablity we observe for these genes is due to technical noise; whereas endogenous genes are affected by both technical noise and biological variability. Technical noise can be removed by fitting a model to the spike-ins and “substracting” this from the endogenous genes. There are several methods available based on this premise (eg. <a href="https://github.com/catavallejos/BASiCS">BASiCS</a>, <a href="https://github.com/PMBio/scLVM">scLVM</a>, <a href="http://bioconductor.org/packages/release/bioc/html/RUVSeq.html">RUVg</a>); each using different noise models and different fitting procedures. Alternatively, one can identify genes which exhibit significant variation beyond technical noise (eg. Distance to median, <a href="http://www.nature.com/nmeth/journal/v10/n11/full/nmeth.2645.html">Highly variable genes</a>). However, there are issues with the use of spike-ins for normalisation (particularly ERCCs, derived from bacterial sequences), including that their variability can, for various reasons, actually be <em>higher</em> than that of endogenous genes.</p>
<p>Given the issues with using spike-ins, better results can often be obtained by using endogenous genes instead. Where we have a large number of endogenous genes that, on average, do not vary systematically between cells and where we expect technical effects to affect a large number of genes (a very common and reasonable assumption), then such methods (for example, the RUVs method) can perform well.</p>
<p>We explore both general approaches below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(RUVSeq)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(scran)
<span class="kw">library</span>(kBET)
<span class="kw">library</span>(sva) <span class="co"># Combat</span>
<span class="kw">library</span>(edgeR)
<span class="kw">library</span>(harmony)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
umi &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/umi.rds&quot;</span>)
umi.qc &lt;-<span class="st"> </span>umi[<span class="kw">rowData</span>(umi)<span class="op">$</span>use, <span class="kw">colData</span>(umi)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(umi.qc)<span class="op">$</span>is_feature_control
erccs &lt;-<span class="st"> </span><span class="kw">rowData</span>(umi.qc)<span class="op">$</span>is_feature_control

qclust &lt;-<span class="st"> </span><span class="kw">quickCluster</span>(umi.qc, <span class="dt">min.size =</span> <span class="dv">30</span>)
umi.qc &lt;-<span class="st"> </span><span class="kw">computeSumFactors</span>(umi.qc, <span class="dt">sizes =</span> <span class="dv">15</span>, <span class="dt">clusters =</span> qclust)
umi.qc &lt;-<span class="st"> </span><span class="kw">normalize</span>(umi.qc)</code></pre>
</div>
</div>
<div id="remove-unwanted-variation" class="section level3">
<h3><span class="header-section-number">7.10.2</span> Remove Unwanted Variation</h3>
<p>Factors contributing to technical noise frequently appear as “batch
effects” where cells processed on different days or by different
technicians systematically vary from one another. Removing technical
noise and correcting for batch effects can frequently be performed
using the same tool or slight variants on it. We will be considering
the <a href="http://bioconductor.org/packages/RUVSeq">Remove Unwanted Variation (RUVSeq)</a>. Briefly, RUVSeq works as follows. For <span class="math inline">\(n\)</span> samples and <span class="math inline">\(J\)</span> genes, consider the following generalized linear model (GLM), where the RNA-Seq read counts are regressed on both the known covariates of interest and unknown factors of unwanted variation:
<span class="math display">\[\log E[Y|W,X,O] = W\alpha + X\beta + O\]</span>
Here, <span class="math inline">\(Y\)</span> is the <span class="math inline">\(n \times J\)</span> matrix of observed gene-level read counts, <span class="math inline">\(W\)</span> is an <span class="math inline">\(n \times k\)</span> matrix corresponding to the factors of “unwanted variation” and <span class="math inline">\(O\)</span> is an <span class="math inline">\(n \times J\)</span> matrix of offsets that can either be set to zero or estimated with some other normalization procedure (such as upper-quartile normalization). The simultaneous estimation of <span class="math inline">\(W\)</span>, <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, and <span class="math inline">\(k\)</span> is infeasible. For a given <span class="math inline">\(k\)</span>, instead the following three
approaches to estimate the factors of unwanted variation <span class="math inline">\(W\)</span> are used:</p>
<ul>
<li><em>RUVg</em> uses negative control genes (e.g. ERCCs), assumed to have constant expression across samples;</li>
<li><em>RUVs</em> uses centered (technical) replicate/negative control samples for which the covariates of interest are
constant;</li>
<li><em>RUVr</em> uses residuals, e.g., from a first-pass GLM regression of the counts on the covariates of interest.</li>
</ul>
<p>We will concentrate on the first two approaches.</p>
<div id="ruvg" class="section level4">
<h4><span class="header-section-number">7.10.2.1</span> RUVg</h4>
<pre class="sourceCode r"><code class="sourceCode r">ruvg &lt;-<span class="st"> </span><span class="kw">RUVg</span>(<span class="kw">counts</span>(umi.qc), erccs, <span class="dt">k =</span> <span class="dv">1</span>)
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;ruvg1&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)
ruvg &lt;-<span class="st"> </span><span class="kw">RUVg</span>(<span class="kw">counts</span>(umi.qc), erccs, <span class="dt">k =</span> <span class="dv">10</span>)
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;ruvg10&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)</code></pre>
</div>
<div id="ruvs" class="section level4">
<h4><span class="header-section-number">7.10.2.2</span> RUVs</h4>
<pre class="sourceCode r"><code class="sourceCode r">scIdx &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dt">ncol =</span> <span class="kw">max</span>(<span class="kw">table</span>(umi.qc<span class="op">$</span>individual)), <span class="dt">nrow =</span> <span class="dv">3</span>)
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>)
scIdx[<span class="dv">1</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>)
scIdx[<span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>)
scIdx[<span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
cIdx &lt;-<span class="st"> </span><span class="kw">rownames</span>(umi.qc)
ruvs &lt;-<span class="st"> </span><span class="kw">RUVs</span>(<span class="kw">counts</span>(umi.qc), cIdx, <span class="dt">k =</span> <span class="dv">1</span>, <span class="dt">scIdx =</span> scIdx, <span class="dt">isLog =</span> <span class="ot">FALSE</span>)
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;ruvs1&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)
ruvs &lt;-<span class="st"> </span><span class="kw">RUVs</span>(<span class="kw">counts</span>(umi.qc), cIdx, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">scIdx =</span> scIdx, <span class="dt">isLog =</span> <span class="ot">FALSE</span>)
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;ruvs10&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)</code></pre>
</div>
</div>
<div id="combat" class="section level3">
<h3><span class="header-section-number">7.10.3</span> Combat</h3>
<p>If you have an experiment with a balanced design, <code>Combat</code> can be used to eliminate batch effects while preserving biological effects by specifying the biological effects using the <code>mod</code> parameter. However the <code>Tung</code> data contains multiple experimental replicates rather than a balanced design so using <code>mod1</code> to preserve biological variability will result in an error.</p>
<pre class="sourceCode r"><code class="sourceCode r">combat_data &lt;-<span class="st"> </span><span class="kw">logcounts</span>(umi.qc)
mod_data &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">t</span>(combat_data))
<span class="co"># Basic batch removal</span>
mod0 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> mod_data) 
<span class="co"># Preserve biological variability</span>
mod1 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>umi.qc<span class="op">$</span>individual, <span class="dt">data =</span> mod_data) 
<span class="co"># adjust for total genes detected</span>
mod2 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>umi.qc<span class="op">$</span>total_features_by_counts, <span class="dt">data =</span> mod_data)
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;combat&quot;</span>) &lt;-<span class="st"> </span><span class="kw">ComBat</span>(
    <span class="dt">dat =</span> <span class="kw">t</span>(mod_data), 
    <span class="dt">batch =</span> <span class="kw">factor</span>(umi.qc<span class="op">$</span>batch), 
    <span class="dt">mod =</span> mod0,
    <span class="dt">par.prior =</span> <span class="ot">TRUE</span>,
    <span class="dt">prior.plots =</span> <span class="ot">FALSE</span>
)</code></pre>
<p><strong>Exercise 1</strong></p>
<p>Perform <code>ComBat</code> correction accounting for total features as a co-variate. Store the corrected matrix in the <code>combat_tf</code> slot.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assay</span>(umi.qc, <span class="st">&quot;combat_tf&quot;</span>) &lt;-<span class="st"> </span><span class="kw">ComBat</span>(
    <span class="dt">dat =</span> <span class="kw">t</span>(mod_data), 
    <span class="dt">batch =</span> <span class="kw">factor</span>(umi.qc<span class="op">$</span>batch), 
    <span class="dt">mod =</span> mod2,
    <span class="dt">par.prior =</span> <span class="ot">TRUE</span>,
    <span class="dt">prior.plots =</span> <span class="ot">FALSE</span>
)</code></pre>
</div>
<div id="mnncorrect" class="section level3">
<h3><span class="header-section-number">7.10.4</span> mnnCorrect</h3>
<p><code>mnnCorrect</code> <span class="citation">(Haghverdi et al. <a href="#ref-Haghverdi2017-vh">2017</a>)</span> assumes that each batch shares at least one biological condition with each other batch. Thus it works well for a variety of balanced experimental designs. However, the <code>Tung</code> data contains multiple replicates for each invidividual rather than balanced batches, thus we will normalized each individual separately. Note that this will remove batch effects between batches within the same individual but not the batch effects between batches in different individuals, due to the confounded experimental design.</p>
<p>Thus we will merge a replicate from each individual to form three batches.</p>
<pre class="sourceCode r"><code class="sourceCode r">do_mnn &lt;-<span class="st"> </span><span class="cf">function</span>(data.qc) {
    batch1 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r1&quot;</span>])
    batch2 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r2&quot;</span>])
    batch3 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r3&quot;</span>])
    
    <span class="cf">if</span> (<span class="kw">ncol</span>(batch2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
        x =<span class="st"> </span><span class="kw">mnnCorrect</span>(
          batch1, batch2, batch3,  
          <span class="dt">k =</span> <span class="dv">20</span>,
          <span class="dt">sigma =</span> <span class="fl">0.1</span>,
          <span class="dt">cos.norm.in =</span> <span class="ot">TRUE</span>,
          <span class="dt">svd.dim =</span> <span class="dv">2</span>
        )
        res1 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">1</span>]]
        res2 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">2</span>]]
        res3 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">3</span>]]
        <span class="kw">dimnames</span>(res1) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch1)
        <span class="kw">dimnames</span>(res2) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch2)
        <span class="kw">dimnames</span>(res3) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch3)
        <span class="kw">return</span>(<span class="kw">cbind</span>(res1, res2, res3))
    } <span class="cf">else</span> {
        x =<span class="st"> </span><span class="kw">mnnCorrect</span>(
          batch1, batch3,  
          <span class="dt">k =</span> <span class="dv">20</span>,
          <span class="dt">sigma =</span> <span class="fl">0.1</span>,
          <span class="dt">cos.norm.in =</span> <span class="ot">TRUE</span>,
          <span class="dt">svd.dim =</span> <span class="dv">2</span>
        )
        res1 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">1</span>]]
        res3 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">2</span>]]
        <span class="kw">dimnames</span>(res1) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch1)
        <span class="kw">dimnames</span>(res3) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch3)
        <span class="kw">return</span>(<span class="kw">cbind</span>(res1, res3))
    }
}

indi1 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>])
indi2 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>])
indi3 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>])

<span class="kw">assay</span>(umi.qc, <span class="st">&quot;mnn&quot;</span>) &lt;-<span class="st"> </span><span class="kw">cbind</span>(indi1, indi2, indi3)

<span class="co"># For a balanced design: </span>
<span class="co">#assay(umi.qc, &quot;mnn&quot;) &lt;- mnnCorrect(</span>
<span class="co">#    list(B1 = logcounts(batch1), B2 = logcounts(batch2), B3 = logcounts(batch3)),  </span>
<span class="co">#    k = 20,</span>
<span class="co">#    sigma = 0.1,</span>
<span class="co">#    cos.norm = TRUE,</span>
<span class="co">#    svd.dim = 2</span>
<span class="co">#)</span></code></pre>
</div>
<div id="glm" class="section level3">
<h3><span class="header-section-number">7.10.5</span> GLM</h3>
<p>A general linear model is a simpler version of <code>Combat</code>. It can correct for batches while preserving biological effects if you have a balanced design. In a confounded/replicate design biological effects will not be fit/preserved. Similar to <code>mnnCorrect</code> we could remove batch effects from each individual separately in order to preserve biological (and technical) variance between individuals. For demonstation purposes we will naively correct all cofounded batch effects:</p>
<pre class="sourceCode r"><code class="sourceCode r">glm_fun &lt;-<span class="st"> </span><span class="cf">function</span>(g, batch, indi) {
  model &lt;-<span class="st"> </span><span class="kw">glm</span>(g <span class="op">~</span><span class="st"> </span>batch <span class="op">+</span><span class="st"> </span>indi)
  model<span class="op">$</span>coef[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># replace intercept with 0 to preserve reference batch.</span>
  <span class="kw">return</span>(model<span class="op">$</span>coef)
}
effects &lt;-<span class="st"> </span><span class="kw">apply</span>(
    <span class="kw">logcounts</span>(umi.qc), 
    <span class="dv">1</span>, 
    glm_fun, 
    <span class="dt">batch =</span> umi.qc<span class="op">$</span>batch, 
    <span class="dt">indi =</span> umi.qc<span class="op">$</span>individual
)
corrected &lt;-<span class="st"> </span><span class="kw">logcounts</span>(umi.qc) <span class="op">-</span><span class="st"> </span><span class="kw">t</span>(effects[<span class="kw">as.numeric</span>(<span class="kw">factor</span>(umi.qc<span class="op">$</span>batch)), ])
<span class="kw">assay</span>(umi.qc, <span class="st">&quot;glm&quot;</span>) &lt;-<span class="st"> </span>corrected</code></pre>
<p><strong>Exercise 2</strong></p>
<p>Perform GLM correction for each individual separately. Store the final corrected matrix in the <code>glm_indi</code> slot.</p>
<pre class="sourceCode r"><code class="sourceCode r">glm_fun1 &lt;-<span class="st"> </span><span class="cf">function</span>(g, batch) {
  model &lt;-<span class="st"> </span><span class="kw">glm</span>(g <span class="op">~</span><span class="st"> </span>batch)
  model<span class="op">$</span>coef[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># replace intercept with 0 to preserve reference batch.</span>
  <span class="kw">return</span>(model<span class="op">$</span>coef)
}

do_glm &lt;-<span class="st"> </span><span class="cf">function</span>(data.qc) {
    effects &lt;-<span class="st"> </span><span class="kw">apply</span>(
        <span class="kw">logcounts</span>(data.qc), 
        <span class="dv">1</span>, 
        glm_fun1, 
        <span class="dt">batch =</span> data.qc<span class="op">$</span>batch
    )
    corrected &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc) <span class="op">-</span><span class="st"> </span><span class="kw">t</span>(effects[<span class="kw">as.numeric</span>(<span class="kw">factor</span>(data.qc<span class="op">$</span>batch)), ])
    <span class="kw">return</span>(corrected)
}
indi1 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>])
indi2 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>])
indi3 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(umi.qc[, umi.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>])

<span class="kw">assay</span>(umi.qc, <span class="st">&quot;glm_indi&quot;</span>) &lt;-<span class="st"> </span><span class="kw">cbind</span>(indi1, indi2, indi3);</code></pre>
</div>
<div id="harmony" class="section level3">
<h3><span class="header-section-number">7.10.6</span> Harmony</h3>
<p>Harmony [Korsunsky2018fast] is a newer batch correction method, which is designed to operate on PC space. The algorithm proceeds to iteratively cluster the cells, with the objective function formulated to promote cells from multiple datasets within each cluster. Once a clustering is obtained, the positions of the centroids of each dataset are obtained on a per-cluster basis and the coordinates are corrected. This procedure is iterated until convergence. Harmony comes with a <code>theta</code> parameter that controls the degree of batch correction (higher values lead to more dataset integration), and can account for multiple experimental and biological factors on input.</p>
<p>Seeing how the end result of Harmony is an altered dimensional reduction space created on the basis of PCA, we plot the obtained manifold here and exclude it from the rest of the follow-ups in the section.</p>
<pre class="sourceCode r"><code class="sourceCode r">umi.qc.endog =<span class="st"> </span>umi.qc[endog_genes,]
umi.qc.endog =<span class="st"> </span><span class="kw">runPCA</span>(umi.qc.endog, <span class="dt">exprs_values =</span> <span class="st">&#39;logcounts&#39;</span>, <span class="dt">ncomponents =</span> <span class="dv">20</span>)
pca &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(umi.qc.endog<span class="op">@</span>reducedDims<span class="op">@</span>listData[[<span class="st">&quot;PCA&quot;</span>]])
harmony_emb &lt;-<span class="st"> </span><span class="kw">HarmonyMatrix</span>(pca, umi.qc.endog<span class="op">$</span>batch, <span class="dt">theta=</span><span class="dv">2</span>, <span class="dt">do_pca=</span><span class="ot">FALSE</span>)
umi.qc.endog<span class="op">@</span>reducedDims<span class="op">@</span>listData[[<span class="st">&#39;harmony&#39;</span>]] &lt;-<span class="st"> </span>harmony_emb

<span class="kw">plotReducedDim</span>(
    umi.qc.endog,
    <span class="dt">use_dimred =</span> <span class="st">&#39;harmony&#39;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-10-1.png" width="90%" style="display: block; margin: auto;" /></p>
</div>
<div id="how-to-evaluate-and-compare-confounder-removal-strategies" class="section level3">
<h3><span class="header-section-number">7.10.7</span> How to evaluate and compare confounder removal strategies</h3>
<p>A key question when considering the different methods for removing confounders is how to quantitatively determine which one is the most effective. The main reason why comparisons are challenging is because it is often difficult to know what corresponds to technical counfounders and what is interesting biological variability. Here, we consider three different metrics which are all reasonable based on our knowledge of the experimental design. Depending on the biological question that you wish to address, it is important to choose a metric that allows you to evaluate the confounders that are likely to be the biggest concern for the given situation.</p>
<div id="effectiveness-1" class="section level4">
<h4><span class="header-section-number">7.10.7.1</span> Effectiveness 1</h4>
<p>We evaluate the effectiveness of the normalization by inspecting the
PCA plot where colour corresponds the technical replicates and shape
corresponds to different biological samples (individuals). Separation of biological samples and
interspersed batches indicates that technical variation has been
removed. We always use log2-cpm normalized data to match the assumptions of PCA.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(n <span class="cf">in</span> <span class="kw">assayNames</span>(umi.qc)) {
    tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
        umi.qc[endog_genes, ],
        <span class="dt">exprs_values =</span> n
    )
    <span class="kw">print</span>(
        <span class="kw">plotPCA</span>(
            tmp,
            <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
            <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
            <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
        ) <span class="op">+</span>
<span class="st">        </span><span class="kw">ggtitle</span>(n)
    )
}</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-1.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-2.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-3.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-4.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-5.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-6.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-7.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-8.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-9.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-10.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-11.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-11-12.png" width="90%" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 3</strong></p>
<p>Consider different <code>ks</code> for RUV normalizations. Which gives the best results?</p>
</div>
<div id="effectiveness-2" class="section level4">
<h4><span class="header-section-number">7.10.7.2</span> Effectiveness 2</h4>
<p>We can also examine the effectiveness of correction using the relative log expression (RLE) across cells to confirm technical noise has been removed from the dataset. Note RLE only evaluates whether the number of genes higher and lower than average are equal for each cell - i.e. systemic technical effects. Random technical noise between batches may not be detected by RLE.</p>
<pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">list</span>()
<span class="cf">for</span>(n <span class="cf">in</span> <span class="kw">assayNames</span>(umi.qc)) {
    res[[n]] &lt;-<span class="st"> </span><span class="kw">suppressWarnings</span>(<span class="kw">calc_cell_RLE</span>(<span class="kw">assay</span>(umi.qc, n), erccs))
}
<span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">1</span>))
<span class="kw">boxplot</span>(res, <span class="dt">las=</span><span class="dv">2</span>)</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-12-1.png" width="90%" style="display: block; margin: auto;" />
#### Effectiveness 3</p>
<p>Another method to check the efficacy of batch-effect correction is to consider the intermingling of points from different batches in local subsamples of the data. If there are no batch-effects then proportion of cells from each batch in any local region should be equal to the global proportion of cells in each batch.</p>
<p><code>kBET</code> <span class="citation">(Buttner et al. <a href="#ref-Buttner2017-ds">2017</a>)</span> takes <code>kNN</code> networks around random cells and tests the number of cells from each batch against a binomial distribution. The rejection rate of these tests indicates the severity of batch-effects still present in the data (high rejection rate = strong batch effects). <code>kBET</code> assumes each batch contains the same complement of biological groups, thus it can only be applied to the entire dataset if a perfectly balanced design has been used. However, <code>kBET</code> can also be applied to replicate-data if it is applied to each biological group separately. In the case of the Tung data, we will apply <code>kBET</code> to each individual independently to check for residual batch effects. However, this method will not identify residual batch-effects which are confounded with biological conditions. In addition, <code>kBET</code> does not determine if biological signal has been preserved.</p>
<pre class="sourceCode r"><code class="sourceCode r">compare_kBET_results &lt;-<span class="st"> </span><span class="cf">function</span>(sce){
    indiv &lt;-<span class="st"> </span><span class="kw">unique</span>(sce<span class="op">$</span>individual)
    norms &lt;-<span class="st"> </span><span class="kw">assayNames</span>(sce) <span class="co"># Get all normalizations</span>
    results &lt;-<span class="st"> </span><span class="kw">list</span>()
    <span class="cf">for</span> (i <span class="cf">in</span> indiv){ 
        <span class="cf">for</span> (j <span class="cf">in</span> norms){
            tmp &lt;-<span class="st"> </span><span class="kw">kBET</span>(
                <span class="dt">df =</span> <span class="kw">t</span>(<span class="kw">assay</span>(sce[,sce<span class="op">$</span>individual<span class="op">==</span><span class="st"> </span>i], j)), 
                <span class="dt">batch =</span> sce<span class="op">$</span>batch[sce<span class="op">$</span>individual<span class="op">==</span>i], 
                <span class="dt">heuristic =</span> <span class="ot">TRUE</span>, 
                <span class="dt">verbose =</span> <span class="ot">FALSE</span>, 
                <span class="dt">addTest =</span> <span class="ot">FALSE</span>, 
                <span class="dt">plot =</span> <span class="ot">FALSE</span>)
            results[[i]][[j]] &lt;-<span class="st"> </span>tmp<span class="op">$</span>summary<span class="op">$</span>kBET.observed[<span class="dv">1</span>]
        }
    }
    <span class="kw">return</span>(<span class="kw">as.data.frame</span>(results))
}

eff_debatching &lt;-<span class="st"> </span><span class="kw">compare_kBET_results</span>(umi.qc)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;reshape2&quot;</span>)
<span class="kw">require</span>(<span class="st">&quot;RColorBrewer&quot;</span>)
<span class="co"># Plot results</span>
dod &lt;-<span class="st"> </span><span class="kw">melt</span>(<span class="kw">as.matrix</span>(eff_debatching),  <span class="dt">value.name =</span> <span class="st">&quot;kBET&quot;</span>)
<span class="kw">colnames</span>(dod)[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Normalisation&quot;</span>, <span class="st">&quot;Individual&quot;</span>)

colorset &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;gray&#39;</span>, <span class="kw">brewer.pal</span>(<span class="dt">n =</span> <span class="dv">9</span>, <span class="st">&quot;RdYlBu&quot;</span>))

<span class="kw">ggplot</span>(dod, <span class="kw">aes</span>(Normalisation, Individual, <span class="dt">fill=</span>kBET)) <span class="op">+</span><span class="st">  </span>
<span class="st">    </span><span class="kw">geom_tile</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_fill_gradient2</span>(
        <span class="dt">na.value =</span> <span class="st">&quot;gray&quot;</span>,
        <span class="dt">low =</span> colorset[<span class="dv">2</span>],
        <span class="dt">mid=</span>colorset[<span class="dv">6</span>],
        <span class="dt">high =</span> colorset[<span class="dv">10</span>],
        <span class="dt">midpoint =</span> <span class="fl">0.5</span>, <span class="dt">limit =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_x_discrete</span>(<span class="dt">expand =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_y_discrete</span>(<span class="dt">expand =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">theme</span>(
        <span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(
            <span class="dt">angle =</span> <span class="dv">45</span>, 
            <span class="dt">vjust =</span> <span class="dv">1</span>, 
            <span class="dt">size =</span> <span class="dv">12</span>, 
            <span class="dt">hjust =</span> <span class="dv">1</span>
        )
    ) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Effect of batch regression methods per individual&quot;</span>)</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf_files/figure-html/unnamed-chunk-14-1.png" width="90%" style="display: block; margin: auto;" />
<strong>Exercise 4</strong></p>
<p>Why do the raw counts appear to have little batch effects?</p>
</div>
</div>
<div id="big-exercise" class="section level3">
<h3><span class="header-section-number">7.10.8</span> Big Exercise</h3>
<p>Perform the same analysis with read counts of the <code>tung</code> data. Use <code>tung/reads.rds</code> file to load the reads <code>SCE</code> object. Once you have finished please compare your results to ours (next chapter). Additionally, experiment with other combinations of normalizations and compare the results.</p>
</div>
</div>
<div id="dealing-with-confounders-reads" class="section level2">
<h2><span class="header-section-number">7.11</span> Dealing with confounders (Reads)</h2>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(RUVSeq)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(scran)
<span class="kw">library</span>(kBET)
<span class="kw">library</span>(sva) <span class="co"># Combat</span>
<span class="kw">library</span>(harmony)
<span class="kw">library</span>(edgeR)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)
<span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
reads &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/tung/reads.rds&quot;</span>)
reads.qc &lt;-<span class="st"> </span>reads[<span class="kw">rowData</span>(reads)<span class="op">$</span>use, <span class="kw">colData</span>(reads)<span class="op">$</span>use]
endog_genes &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">rowData</span>(reads.qc)<span class="op">$</span>is_feature_control
erccs &lt;-<span class="st"> </span><span class="kw">rowData</span>(reads.qc)<span class="op">$</span>is_feature_control

qclust &lt;-<span class="st"> </span><span class="kw">quickCluster</span>(reads.qc, <span class="dt">min.size =</span> <span class="dv">30</span>)
reads.qc &lt;-<span class="st"> </span><span class="kw">computeSumFactors</span>(reads.qc, <span class="dt">sizes =</span> <span class="dv">15</span>, <span class="dt">clusters =</span> qclust)
reads.qc &lt;-<span class="st"> </span><span class="kw">normalize</span>(reads.qc)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">ruvg &lt;-<span class="st"> </span><span class="kw">RUVg</span>(<span class="kw">counts</span>(reads.qc), erccs, <span class="dt">k =</span> <span class="dv">1</span>)
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;ruvg1&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)
ruvg &lt;-<span class="st"> </span><span class="kw">RUVg</span>(<span class="kw">counts</span>(reads.qc), erccs, <span class="dt">k =</span> <span class="dv">10</span>)
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;ruvg10&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvg<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">scIdx &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dt">ncol =</span> <span class="kw">max</span>(<span class="kw">table</span>(reads.qc<span class="op">$</span>individual)), <span class="dt">nrow =</span> <span class="dv">3</span>)
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>)
scIdx[<span class="dv">1</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>)
scIdx[<span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
tmp &lt;-<span class="st"> </span><span class="kw">which</span>(reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>)
scIdx[<span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tmp)] &lt;-<span class="st"> </span>tmp
cIdx &lt;-<span class="st"> </span><span class="kw">rownames</span>(reads.qc)
ruvs &lt;-<span class="st"> </span><span class="kw">RUVs</span>(<span class="kw">counts</span>(reads.qc), cIdx, <span class="dt">k =</span> <span class="dv">1</span>, <span class="dt">scIdx =</span> scIdx, <span class="dt">isLog =</span> <span class="ot">FALSE</span>)
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;ruvs1&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)
ruvs &lt;-<span class="st"> </span><span class="kw">RUVs</span>(<span class="kw">counts</span>(reads.qc), cIdx, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">scIdx =</span> scIdx, <span class="dt">isLog =</span> <span class="ot">FALSE</span>)
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;ruvs10&quot;</span>) &lt;-<span class="st"> </span><span class="kw">log2</span>(
    <span class="kw">t</span>(<span class="kw">t</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">/</span><span class="st"> </span><span class="kw">colSums</span>(ruvs<span class="op">$</span>normalizedCounts) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">combat_data &lt;-<span class="st"> </span><span class="kw">logcounts</span>(reads.qc)
mod_data &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">t</span>(combat_data))
<span class="co"># Basic batch removal</span>
mod0 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> mod_data) 
<span class="co"># Preserve biological variability</span>
mod1 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>reads.qc<span class="op">$</span>individual, <span class="dt">data =</span> mod_data) 
<span class="co"># adjust for total genes detected</span>
mod2 =<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>reads.qc<span class="op">$</span>total_features_by_counts, <span class="dt">data =</span> mod_data)
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;combat&quot;</span>) &lt;-<span class="st"> </span><span class="kw">ComBat</span>(
    <span class="dt">dat =</span> <span class="kw">t</span>(mod_data), 
    <span class="dt">batch =</span> <span class="kw">factor</span>(reads.qc<span class="op">$</span>batch), 
    <span class="dt">mod =</span> mod0,
    <span class="dt">par.prior =</span> <span class="ot">TRUE</span>,
    <span class="dt">prior.plots =</span> <span class="ot">FALSE</span>
)</code></pre>
<p><strong>Exercise 1</strong></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assay</span>(reads.qc, <span class="st">&quot;combat_tf&quot;</span>) &lt;-<span class="st"> </span><span class="kw">ComBat</span>(
    <span class="dt">dat =</span> <span class="kw">t</span>(mod_data), 
    <span class="dt">batch =</span> <span class="kw">factor</span>(reads.qc<span class="op">$</span>batch), 
    <span class="dt">mod =</span> mod2,
    <span class="dt">par.prior =</span> <span class="ot">TRUE</span>,
    <span class="dt">prior.plots =</span> <span class="ot">FALSE</span>
)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">do_mnn &lt;-<span class="st"> </span><span class="cf">function</span>(data.qc) {
    batch1 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r1&quot;</span>])
    batch2 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r2&quot;</span>])
    batch3 &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc[, data.qc<span class="op">$</span>replicate <span class="op">==</span><span class="st"> &quot;r3&quot;</span>])
    
    <span class="cf">if</span> (<span class="kw">ncol</span>(batch2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
        x =<span class="st"> </span><span class="kw">mnnCorrect</span>(
          batch1, batch2, batch3,  
          <span class="dt">k =</span> <span class="dv">20</span>,
          <span class="dt">sigma =</span> <span class="fl">0.1</span>,
          <span class="dt">cos.norm.in =</span> <span class="ot">TRUE</span>,
          <span class="dt">svd.dim =</span> <span class="dv">2</span>
        )
        res1 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">1</span>]]
        res2 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">2</span>]]
        res3 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">3</span>]]
        <span class="kw">dimnames</span>(res1) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch1)
        <span class="kw">dimnames</span>(res2) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch2)
        <span class="kw">dimnames</span>(res3) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch3)
        <span class="kw">return</span>(<span class="kw">cbind</span>(res1, res2, res3))
    } <span class="cf">else</span> {
        x =<span class="st"> </span><span class="kw">mnnCorrect</span>(
          batch1, batch3,  
          <span class="dt">k =</span> <span class="dv">20</span>,
          <span class="dt">sigma =</span> <span class="fl">0.1</span>,
          <span class="dt">cos.norm.in =</span> <span class="ot">TRUE</span>,
          <span class="dt">svd.dim =</span> <span class="dv">2</span>
        )
        res1 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">1</span>]]
        res3 &lt;-<span class="st"> </span>x<span class="op">$</span>corrected[[<span class="dv">2</span>]]
        <span class="kw">dimnames</span>(res1) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch1)
        <span class="kw">dimnames</span>(res3) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(batch3)
        <span class="kw">return</span>(<span class="kw">cbind</span>(res1, res3))
    }
}

indi1 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>])
indi2 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>])
indi3 &lt;-<span class="st"> </span><span class="kw">do_mnn</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>])

<span class="kw">assay</span>(reads.qc, <span class="st">&quot;mnn&quot;</span>) &lt;-<span class="st"> </span><span class="kw">cbind</span>(indi1, indi2, indi3)

<span class="co"># For a balanced design: </span>
<span class="co">#assay(reads.qc, &quot;mnn&quot;) &lt;- mnnCorrect(</span>
<span class="co">#    list(B1 = logcounts(batch1), B2 = logcounts(batch2), B3 = logcounts(batch3)),  </span>
<span class="co">#    k = 20,</span>
<span class="co">#    sigma = 0.1,</span>
<span class="co">#    cos.norm = TRUE,</span>
<span class="co">#    svd.dim = 2</span>
<span class="co">#)</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r">glm_fun &lt;-<span class="st"> </span><span class="cf">function</span>(g, batch, indi) {
  model &lt;-<span class="st"> </span><span class="kw">glm</span>(g <span class="op">~</span><span class="st"> </span>batch <span class="op">+</span><span class="st"> </span>indi)
  model<span class="op">$</span>coef[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># replace intercept with 0 to preserve reference batch.</span>
  <span class="kw">return</span>(model<span class="op">$</span>coef)
}
effects &lt;-<span class="st"> </span><span class="kw">apply</span>(
    <span class="kw">logcounts</span>(reads.qc), 
    <span class="dv">1</span>, 
    glm_fun, 
    <span class="dt">batch =</span> reads.qc<span class="op">$</span>batch, 
    <span class="dt">indi =</span> reads.qc<span class="op">$</span>individual
)
corrected &lt;-<span class="st"> </span><span class="kw">logcounts</span>(reads.qc) <span class="op">-</span><span class="st"> </span><span class="kw">t</span>(effects[<span class="kw">as.numeric</span>(<span class="kw">factor</span>(reads.qc<span class="op">$</span>batch)), ])
<span class="kw">assay</span>(reads.qc, <span class="st">&quot;glm&quot;</span>) &lt;-<span class="st"> </span>corrected</code></pre>
<p><strong>Exercise 2</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">glm_fun1 &lt;-<span class="st"> </span><span class="cf">function</span>(g, batch) {
  model &lt;-<span class="st"> </span><span class="kw">glm</span>(g <span class="op">~</span><span class="st"> </span>batch)
  model<span class="op">$</span>coef[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># replace intercept with 0 to preserve reference batch.</span>
  <span class="kw">return</span>(model<span class="op">$</span>coef)
}

do_glm &lt;-<span class="st"> </span><span class="cf">function</span>(data.qc) {
    effects &lt;-<span class="st"> </span><span class="kw">apply</span>(
        <span class="kw">logcounts</span>(data.qc), 
        <span class="dv">1</span>, 
        glm_fun1, 
        <span class="dt">batch =</span> data.qc<span class="op">$</span>batch
    )
    corrected &lt;-<span class="st"> </span><span class="kw">logcounts</span>(data.qc) <span class="op">-</span><span class="st"> </span><span class="kw">t</span>(effects[<span class="kw">as.numeric</span>(<span class="kw">factor</span>(data.qc<span class="op">$</span>batch)), ])
    <span class="kw">return</span>(corrected)
}
indi1 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19098&quot;</span>])
indi2 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>])
indi3 &lt;-<span class="st"> </span><span class="kw">do_glm</span>(reads.qc[, reads.qc<span class="op">$</span>individual <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>])

<span class="kw">assay</span>(reads.qc, <span class="st">&quot;glm_indi&quot;</span>) &lt;-<span class="st"> </span><span class="kw">cbind</span>(indi1, indi2, indi3);</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">reads.qc.endog =<span class="st"> </span>reads.qc[endog_genes,]
reads.qc.endog =<span class="st"> </span><span class="kw">runPCA</span>(reads.qc.endog, <span class="dt">exprs_values =</span> <span class="st">&#39;logcounts&#39;</span>, <span class="dt">ncomponents =</span> <span class="dv">20</span>)
pca &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(reads.qc.endog<span class="op">@</span>reducedDims<span class="op">@</span>listData[[<span class="st">&quot;PCA&quot;</span>]])
harmony_emb &lt;-<span class="st"> </span><span class="kw">HarmonyMatrix</span>(pca, reads.qc.endog<span class="op">$</span>batch, <span class="dt">theta=</span><span class="dv">2</span>, <span class="dt">do_pca=</span><span class="ot">FALSE</span>)
reads.qc.endog<span class="op">@</span>reducedDims<span class="op">@</span>listData[[<span class="st">&#39;harmony&#39;</span>]] &lt;-<span class="st"> </span>harmony_emb

<span class="kw">plotReducedDim</span>(
    reads.qc.endog,
    <span class="dt">use_dimred =</span> <span class="st">&#39;harmony&#39;</span>,
    <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
    <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
    <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
)</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-10-1.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(n <span class="cf">in</span> <span class="kw">assayNames</span>(reads.qc)) {
    tmp &lt;-<span class="st"> </span><span class="kw">runPCA</span>(
        reads.qc[endog_genes, ],
        <span class="dt">exprs_values =</span> n
    )
    <span class="kw">print</span>(
        <span class="kw">plotPCA</span>(
            tmp,
            <span class="dt">colour_by =</span> <span class="st">&quot;batch&quot;</span>,
            <span class="dt">size_by =</span> <span class="st">&quot;total_features_by_counts&quot;</span>,
            <span class="dt">shape_by =</span> <span class="st">&quot;individual&quot;</span>
        ) <span class="op">+</span>
<span class="st">        </span><span class="kw">ggtitle</span>(n)
    )
}</code></pre>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-1.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-2.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-3.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-4.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-5.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-6.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-7.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-8.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-9.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-10.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-11.png" width="90%" style="display: block; margin: auto;" /><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-11-12.png" width="90%" style="display: block; margin: auto;" /></p>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-12-1.png" width="90%" style="display: block; margin: auto;" /></p>
<p><img src="https://scrnaseq-course.cog.sanger.ac.uk/website/remove-conf-reads_files/figure-html/unnamed-chunk-14-1.png" width="90%" style="display: block; margin: auto;" /></p>
<pre><code>## R version 3.6.0 (2019-04-26)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 7 x64 (build 7601) Service Pack 1
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Chinese (Simplified)_People&#39;s Republic of China.936 
## [2] LC_CTYPE=Chinese (Simplified)_People&#39;s Republic of China.936   
## [3] LC_MONETARY=Chinese (Simplified)_People&#39;s Republic of China.936
## [4] LC_NUMERIC=C                                                   
## [5] LC_TIME=Chinese (Simplified)_People&#39;s Republic of China.936    
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] scran_1.12.1                scRNA.seq.funcs_0.1.0      
##  [3] limma_3.40.2                scater_1.12.2              
##  [5] ggplot2_3.2.0               SingleCellExperiment_1.6.0 
##  [7] SummarizedExperiment_1.14.0 DelayedArray_0.10.0        
##  [9] BiocParallel_1.17.18        matrixStats_0.54.0         
## [11] Biobase_2.44.0              GenomicRanges_1.36.0       
## [13] GenomeInfoDb_1.20.0         IRanges_2.18.1             
## [15] S4Vectors_0.22.0            BiocGenerics_0.30.0        
## [17] knitr_1.23                 
## 
## loaded via a namespace (and not attached):
##   [1] Rtsne_0.15               ggbeeswarm_0.6.0        
##   [3] colorspace_1.4-1         mvoutlier_2.0.9         
##   [5] class_7.3-15             modeltools_0.2-22       
##   [7] rio_0.5.16               dynamicTreeCut_1.63-1   
##   [9] mclust_5.4.4             XVector_0.24.0          
##  [11] pls_2.7-1                BiocNeighbors_1.2.0     
##  [13] cvTools_0.3.2            flexmix_2.3-15          
##  [15] mvtnorm_1.0-11           ranger_0.11.2           
##  [17] splines_3.6.0            sROC_0.1-2              
##  [19] robustbase_0.93-5        robCompositions_2.1.0   
##  [21] cluster_2.1.0            kernlab_0.9-27          
##  [23] rrcov_1.4-7              compiler_3.6.0          
##  [25] dqrng_0.2.1              assertthat_0.2.1        
##  [27] Matrix_1.2-17            lazyeval_0.2.2          
##  [29] BiocSingular_1.0.0       htmltools_0.3.6         
##  [31] tools_3.6.0              igraph_1.2.4.1          
##  [33] rsvd_1.0.1               gtable_0.3.0            
##  [35] glue_1.3.1               GenomeInfoDbData_1.2.1  
##  [37] dplyr_0.8.2              Rcpp_1.0.1              
##  [39] carData_3.0-2            cellranger_1.1.0        
##  [41] zCompositions_1.3.2-1    sgeostat_1.0-27         
##  [43] fpc_2.2-3                DelayedMatrixStats_1.6.0
##  [45] lmtest_0.9-37            xfun_0.8                
##  [47] laeken_0.5.0             stringr_1.4.0           
##  [49] openxlsx_4.1.0.1         irlba_2.3.3             
##  [51] hypergeo_1.2-13          statmod_1.4.32          
##  [53] edgeR_3.26.5             DEoptimR_1.0-8          
##  [55] zlibbioc_1.30.0          MASS_7.3-51.4           
##  [57] zoo_1.8-6                scales_1.0.0            
##  [59] VIM_4.8.0                hms_0.4.2               
##  [61] RColorBrewer_1.1-2       yaml_2.2.0              
##  [63] curl_3.3                 NADA_1.6-1              
##  [65] gridExtra_2.3            reshape_0.8.8           
##  [67] stringi_1.4.3            highr_0.8               
##  [69] pcaPP_1.9-73             orthopolynom_1.0-5      
##  [71] e1071_1.7-2              contfrac_1.1-12         
##  [73] boot_1.3-22              zip_2.0.2               
##  [75] truncnorm_1.0-8          moments_0.14            
##  [77] rlang_0.4.0              pkgconfig_2.0.2         
##  [79] prabclus_2.3-1           bitops_1.0-6            
##  [81] evaluate_0.14            lattice_0.20-38         
##  [83] purrr_0.3.2              labeling_0.3            
##  [85] cowplot_0.9.4            tidyselect_0.2.5        
##  [87] deSolve_1.23             GGally_1.4.0            
##  [89] plyr_1.8.4               magrittr_1.5            
##  [91] bookdown_0.11            R6_2.4.0                
##  [93] pillar_1.4.2             haven_2.1.0             
##  [95] foreign_0.8-71           withr_2.1.2             
##  [97] survival_2.44-1.1        abind_1.4-5             
##  [99] RCurl_1.95-4.12          sp_1.3-1                
## [101] nnet_7.3-12              tibble_2.1.3            
## [103] crayon_1.3.4             car_3.0-3               
## [105] rmarkdown_1.13           viridis_0.5.1           
## [107] locfit_1.5-9.1           grid_3.6.0              
## [109] readxl_1.3.1             data.table_1.12.2       
## [111] forcats_0.4.0            vcd_1.4-4               
## [113] digest_0.6.19            diptest_0.75-7          
## [115] tidyr_0.8.3              elliptic_1.4-0          
## [117] munsell_0.5.0            beeswarm_0.2.3          
## [119] viridisLite_0.3.0        vipor_0.4.5</code></pre>

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-Anders2010-jr">
<p>Anders, Simon, and Wolfgang Huber. 2010. “Differential Expression Analysis for Sequence Count Data.” <em>Genome Biol</em> 11 (10): R106. <a href="https://doi.org/10.1186/gb-2010-11-10-r106">https://doi.org/10.1186/gb-2010-11-10-r106</a>.</p>
</div>
<div id="ref-Bullard2010-eb">
<p>Bullard, James H, Elizabeth Purdom, Kasper D Hansen, and Sandrine Dudoit. 2010. “Evaluation of Statistical Methods for Normalization and Differential Expression in mRNA-Seq Experiments.” <em>BMC Bioinformatics</em> 11 (1): 94. <a href="https://doi.org/10.1186/1471-2105-11-94">https://doi.org/10.1186/1471-2105-11-94</a>.</p>
</div>
<div id="ref-Buttner2017-ds">
<p>Buttner, Maren, Zhichao Miao, Alexander Wolf, Sarah A Teichmann, and Fabian J Theis. 2017. “Assessment of Batch-Correction Methods for scRNA-seq Data with a New Test Metric.” <em>bioRxiv</em>, October, 200345.</p>
</div>
<div id="ref-Haghverdi2017-vh">
<p>Haghverdi, Laleh, Aaron T L Lun, Michael D Morgan, and John C Marioni. 2017. “Correcting Batch Effects in Single-Cell RNA Sequencing Data by Matching Mutual Nearest Neighbours.” <em>bioRxiv</em>, July, 165118.</p>
</div>
<div id="ref-L_Lun2016-pq">
<p>L. Lun, Aaron T., Karsten Bach, and John C. Marioni. 2016. “Pooling Across Cells to Normalize Single-Cell RNA Sequencing Data with Many Zero Counts.” <em>Genome Biol</em> 17 (1). <a href="https://doi.org/10.1186/s13059-016-0947-7">https://doi.org/10.1186/s13059-016-0947-7</a>.</p>
</div>
<div id="ref-Robinson2010-hz">
<p>Robinson, Mark D, and Alicia Oshlack. 2010. “A Scaling Normalization Method for Differential Expression Analysis of RNA-Seq Data.” <em>Genome Biol</em> 11 (3): R25. <a href="https://doi.org/10.1186/gb-2010-11-3-r25">https://doi.org/10.1186/gb-2010-11-3-r25</a>.</p>
</div>
<div id="ref-Tung2017-ba">
<p>Tung, Po-Yuan, John D. Blischak, Chiaowen Joyce Hsiao, David A. Knowles, Jonathan E. Burnett, Jonathan K. Pritchard, and Yoav Gilad. 2017. “Batch Effects and the Effective Design of Single-Cell Gene Expression Studies.” <em>Sci. Rep.</em> 7 (January): 39921. <a href="https://doi.org/10.1038/srep39921">https://doi.org/10.1038/srep39921</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="tabula-muris.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="references.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": true,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/lemonbases/scRNA.seq.course.CN/edit/master/07exprs-overview.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["scRNA-seq-course.pdf"],
"toc": {
"collapse": "section"
},
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
